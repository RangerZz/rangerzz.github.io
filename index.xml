<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ranger&#39;s blog</title>
    <link>https://rangerzz.github.io/</link>
    <description>Recent content on Ranger&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 21 Aug 2018 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://rangerzz.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://rangerzz.github.io/about/</link>
      <pubDate>Tue, 21 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://rangerzz.github.io/about/</guid>
      
        <description>&lt;p&gt;Ranger的博客站。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>HTTP基础(上)</title>
      <link>https://rangerzz.github.io/post/11/</link>
      <pubDate>Sun, 04 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://rangerzz.github.io/post/11/</guid>
      
        <description>

&lt;h2 id=&#34;osi网络分层&#34;&gt;OSI网络分层&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分层&lt;/th&gt;
&lt;th&gt;OSI分层&lt;/th&gt;
&lt;th&gt;该层协议&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;应用层&lt;/td&gt;
&lt;td&gt;应用层&lt;/td&gt;
&lt;td&gt;http、ssh、smtp、pop、ssl/tls、ftp、mime、DNS&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;表示层&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;会话层&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;传输层&lt;/td&gt;
&lt;td&gt;传输层&lt;/td&gt;
&lt;td&gt;tcp、udp&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;网络层&lt;/td&gt;
&lt;td&gt;网络层&lt;/td&gt;
&lt;td&gt;ip4、ip6、ARP（解析地址、根据ip地址反查出对应MAC地址）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;链路层&lt;/td&gt;
&lt;td&gt;数据链路层&lt;/td&gt;
&lt;td&gt;以太网、网线、光纤&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;物理层&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;三次握手&#34;&gt;三次握手&lt;/h2&gt;

&lt;p&gt;握手过程中使用了TCP的标志（flag）
SYN：synchronize
ACK：acknowledgement&lt;/p&gt;

&lt;p&gt;发送端-&amp;gt;接收端：发送标有SYN的数据包&lt;/p&gt;

&lt;p&gt;接收端-&amp;gt;发送端：接收到数据包，发送标有SYN/ACK的数据包&lt;/p&gt;

&lt;p&gt;发送端-&amp;gt;接收端：收到数据包，发送标有ACK的数据包，握手结束&lt;/p&gt;

&lt;p&gt;如果某个阶段莫名中断，TCP协议会再次握手&lt;/p&gt;

&lt;h3 id=&#34;tcp的三次握手过程-为什么会采用三次握手-若采用二次握手可以吗&#34;&gt;TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？&lt;/h3&gt;

&lt;p&gt;答:建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。&lt;/p&gt;

&lt;p&gt;（1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。&lt;/p&gt;

&lt;p&gt;（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。&lt;/p&gt;

&lt;p&gt;（3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况&lt;/p&gt;

&lt;h2 id=&#34;四次挥手&#34;&gt;四次挥手&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;media/15638366103723/15638384794987.jpg&#34; alt=&#34;&#34; /&gt;
A为客户端，B为服务端&lt;/p&gt;

&lt;p&gt;为什么是四次呢？
TCP采用全双工模式&lt;/p&gt;

&lt;p&gt;全双工模式：可以同时进行双向的数据传输，所以AB既是发送端又是接收端，所以每次断开连接，需要一个发送端发送FIN断开请求，接收端发送ACK确认断开请求，两个连接，四次挥手&lt;/p&gt;

&lt;p&gt;第一次分手：A发送FIN报文段给B，用来断开客户端到服务端的连接，此时A处于FIN_WAIT_1状态，等待B断开连接的确认&lt;/p&gt;

&lt;p&gt;第二次分手：B收到A的FIN报文段后，回传一个ACK报文段，同意客户端的断开请求，此时B进入CLOSE_WAIT状态，等待A关闭连接，A收到B的ACK后，A关闭向B发送数据的连接，A进入FIN_WAIT_2状态&lt;/p&gt;

&lt;p&gt;第三次挥手：A到B的连接断开后，B发送FIN报文段给A，请求断开服务端到客户端的连接，B进入LAST_ACK状态，等待A断开连接的确认&lt;/p&gt;

&lt;p&gt;第四次挥手：A收到B的FIN后，回传一个ACK，同意关闭连接，此时A进入TIME_WAIT状态，B收到A的ACK报文段后，关闭服务端向客户端发送数据的连接，B进入CLOSED状态，此时客户端还处于TIME_WAIT，等待两个MSL时间后，自动进入CLOSED状态&lt;/p&gt;

&lt;h2 id=&#34;dns服务&#34;&gt;DNS服务&lt;/h2&gt;

&lt;p&gt;域名-解析-&amp;gt;IP地址&lt;/p&gt;

&lt;p&gt;发送端-域名-&amp;gt;DNS
DNS-IP-&amp;gt;发送端
发送端-IP-&amp;gt;对应IP地址的服务器&lt;/p&gt;

&lt;h2 id=&#34;一次完整http通信过程&#34;&gt;一次完整HTTP通信过程&lt;/h2&gt;

&lt;p&gt;客户端-域名-&amp;gt;DNS&lt;/p&gt;

&lt;p&gt;DNS-IP-&amp;gt;客户端&lt;/p&gt;

&lt;p&gt;HTTP协议的职责：生成对目标Web服务器的请求报文&lt;/p&gt;

&lt;p&gt;TCP协议的职责：为了方便通信，将HTTP请求报文按序号分割成多个报文段，把每个报文段可靠度传给对方&lt;/p&gt;

&lt;p&gt;IP协议的职责：搜索对方地址，一边中转一遍传送&lt;/p&gt;

&lt;p&gt;TCP协议的职责：收到报文段后，按序号重组请求报文&lt;/p&gt;

&lt;p&gt;HTTP协议的职责：解析客户端对Web服务器的请求的内容的处理&lt;/p&gt;

&lt;p&gt;请求处理的结果也同样利用TCP/IP协议向客户端回传&lt;/p&gt;

&lt;h2 id=&#34;http协议报文&#34;&gt;HTTP协议报文&lt;/h2&gt;

&lt;p&gt;请求报文由请求方法、请求URI、协议版本、可选的请求首部字段、内容实体构成&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;POST(请求方法) /from(请求URI) HTTP/1.1(协议版本)

Host:google.com
Connection:keep-live
Content-Type:application/x-www-form-urlencoded
Content-Length:16
...
(请求首部字段)

name=uers(内容实体)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;响应报文由协议版本、状态码、解释状态码的原因短语、可选的响应首部字段和实体主体构成&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;HTTP/1.1 200 OK
Date:Tue, 10..
Content-Length:36
Content-Type:text/html

&amp;lt;html&amp;gt;...&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;cookie&#34;&gt;Cookie&lt;/h2&gt;

&lt;p&gt;HTTP是无状态协议，不对发生过的请求和响应的状态进行管理，无法根据之前的状态进行本次的请求处理
由此产生的问题例如Web保存登录状态
Cookie技术通过在请求和响应报文（首部字段）中写入Cookie信息来控制客户端的状态&lt;/p&gt;

&lt;h3 id=&#34;请求过程&#34;&gt;请求过程&lt;/h3&gt;

&lt;p&gt;A客户端 B服务器&lt;/p&gt;

&lt;p&gt;没有cookie状态下
A-请求（无cookie）-&amp;gt;B
B（Set-Cookie）-响应（带Set-Cookie）-&amp;gt;A(保存cookie)&lt;/p&gt;

&lt;p&gt;有cookie状态下
A-请求（cookie）-&amp;gt;B检查cookie
B-响应（根据cookie）-&amp;gt;A&lt;/p&gt;

&lt;h2 id=&#34;状态码&#34;&gt;状态码&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;类别&lt;/th&gt;
&lt;th&gt;原因&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1XX&lt;/td&gt;
&lt;td&gt;Information 信息性状态码&lt;/td&gt;
&lt;td&gt;接收的请求正在处理&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2XX&lt;/td&gt;
&lt;td&gt;Success 成功状态码&lt;/td&gt;
&lt;td&gt;请求正常处理完毕&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3XX&lt;/td&gt;
&lt;td&gt;Redirection 重定向状态码&lt;/td&gt;
&lt;td&gt;需要进行附加操作以完成请求&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4XX&lt;/td&gt;
&lt;td&gt;Client Error 客户端错误状态码&lt;/td&gt;
&lt;td&gt;服务器无法处理请求&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5XX&lt;/td&gt;
&lt;td&gt;Server Error 服务器错误状态码&lt;/td&gt;
&lt;td&gt;服务器处理请求出错&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;常见状态码&#34;&gt;常见状态码&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;200 OK 表示从客户端发来的请求在服务端被正常处理了&lt;/li&gt;
&lt;li&gt;202 No Content 表示服务器成功处理了请求，但在返回响应报文中不含实体的主体部分，一般在只需要客户端往服务端发送信息时使用&lt;/li&gt;
&lt;li&gt;204 Partial Cotent 表示客户端进行了范围请求，服务器成功执行了这部分的GET请求&lt;/li&gt;
&lt;li&gt;301 Moved Permanently 永久性重定向，表示请求的资源已被分配新的URI，以后应使用新的URI&lt;/li&gt;
&lt;li&gt;302 Found 临时性重定向 ，表示请求的资源已被分配新的URI，希望本次使用新的URI访问&lt;/li&gt;
&lt;li&gt;303 See Other 表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源&lt;/li&gt;
&lt;li&gt;304 Not Modified 表示客户端发送附带条件（If-Match、If-Modified-Since等）的请求时，服务器允许请求访问资源，但是未满足条件，直接返回304（可直接使用客户端未过期的缓存）&lt;/li&gt;
&lt;li&gt;307 Temporary Redirect 临时重定向 类似302，每种浏览器行为不一致&lt;/li&gt;
&lt;li&gt;400 Bad Request 表示请求报文中存在语法错误&lt;/li&gt;
&lt;li&gt;401 Unauthorized 表示发送的请求需要通过HTTP认证（BASIC、DIGEST认证），若之前已经进行过一次请求，则表示用户认证失败&lt;/li&gt;
&lt;li&gt;403 Forbidden 表示请求资源的访问被服务器拒绝了&lt;/li&gt;
&lt;li&gt;404 Not Found 表示服务器上无法找到请求的资源&lt;/li&gt;
&lt;li&gt;500 Internal Server Error 表示服务器执行请求时发生了错误&lt;/li&gt;
&lt;li&gt;503 Service Unavailable 表示服务器处于超负载或者维护中，无法处理请求&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;http的缺点&#34;&gt;HTTP的缺点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;通信使用明文（不加密），内容可能会被窃听&lt;/li&gt;
&lt;li&gt;不验证通信方的身份，有可能遭遇伪装&lt;/li&gt;
&lt;li&gt;无法证明报文的完整性，有可能已遭篡改&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>堆栈</title>
      <link>https://rangerzz.github.io/post/9/</link>
      <pubDate>Tue, 09 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://rangerzz.github.io/post/9/</guid>
      
        <description>

&lt;h2 id=&#34;堆栈&#34;&gt;堆栈&lt;/h2&gt;

&lt;h3 id=&#34;抽象数据类型描述&#34;&gt;抽象数据类型描述&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;具有一定操作约束的线性表,只在一端(栈顶,Top)做插入,删除&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;插入数据:入栈(Push)&lt;/li&gt;
&lt;li&gt;删除数据:出栈(Pop)&lt;/li&gt;
&lt;li&gt;后入先出:Last In First Out(LIFO)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;类型名称-堆栈-stack&#34;&gt;类型名称:堆栈(Stack)&lt;/h4&gt;

&lt;h4 id=&#34;数据对象集-一个-有0个或多个元素的有穷线性表&#34;&gt;数据对象集:一个 有0个或多个元素的有穷线性表&lt;/h4&gt;

&lt;h4 id=&#34;操作集&#34;&gt;操作集&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;创建空堆栈&lt;/li&gt;
&lt;li&gt;判断堆栈是否已满&lt;/li&gt;
&lt;li&gt;将元素压入堆栈&lt;/li&gt;
&lt;li&gt;判断堆栈是否为空&lt;/li&gt;
&lt;li&gt;删除并返回栈顶元素&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;堆栈的顺序存储实现&#34;&gt;堆栈的顺序存储实现&lt;/h2&gt;

&lt;p&gt;通常由一个一维数组和一个记录栈顶元素位置的变量组成&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;class Stack&amp;lt;T:Hashable&amp;gt; {
    var data : Array&amp;lt;T&amp;gt; = Array();
    var top : Int = -1
    
    
    func push(_ item:T) -&amp;gt; Void {
        data.append(item)
        top += 1
    }
    
    func pop() -&amp;gt; T? {
        if top == -1 {
            print(&amp;#34;空堆栈&amp;#34;)
            return nil
        }
        top -= 1
        return data.popLast()
    }
}

let stack = Stack&amp;lt;Int&amp;gt;()
stack.push(0)
stack.push(1)

print(stack.pop())
print(stack.top)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;堆栈的链式存储实现&#34;&gt;堆栈的链式存储实现&lt;/h2&gt;

&lt;p&gt;堆栈的链式存储结构实际上是一个单链表,叫做链栈,插入和删除操作只能在链栈的栈顶进行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;class StackNode&amp;lt;T:Hashable&amp;gt; {
    var data : T?
    var next : StackNode?
}

class Stack&amp;lt;T:Hashable&amp;gt; {
    var top = StackNode&amp;lt;T&amp;gt;()// 指向栈顶,本身无意义
    
    func isEmpty() -&amp;gt; Bool {
        if top.next == nil {
            return true
        }
        else {
            return false
        }
    }
    
    func push(_ item:T) -&amp;gt; Void {
        let node = StackNode&amp;lt;T&amp;gt;();
        node.data = item;
        node.next = top.next;
        top.next = node
    }
    
    func pop() -&amp;gt; T? {
        if isEmpty() {
            print(&amp;#34;空堆栈&amp;#34;)
            return nil
        }
        
        let node = top.next
        top.next = top.next?.next
        return node!.data
    }
}

let stack = Stack&amp;lt;String&amp;gt;()
stack.push(&amp;#34;aaa&amp;#34;)
stack.push(&amp;#34;bbb&amp;#34;)
print(stack.top.next?.data)
print(stack.pop())
print(stack.pop())
print(stack.isEmpty())
stack.push(&amp;#34;cccc&amp;#34;)
print(stack.top.next?.data)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;堆栈应用&#34;&gt;堆栈应用&lt;/h2&gt;

&lt;h3 id=&#34;后缀表达式求值&#34;&gt;后缀表达式求值&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;从左向右扫描,逐个处理运算数和运算符号&lt;/li&gt;
&lt;li&gt;遇到运算数,入栈&lt;/li&gt;
&lt;li&gt;遇到运算符,出栈两个运算数,做运算&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;class ExpressionOperation {
    func input(expression:[String]) -&amp;gt; Int {
        let stack = Stack&amp;lt;Int&amp;gt;()
        
        for value in expression {
            if isInt(string: value) {
                stack.push(Int(value)!)
            }
            else {
                let a = stack.pop()!
                let b = stack.pop()!
                var ret = 0
                
                switch value {
                    case &amp;#34;+&amp;#34;:
                        ret = a + b;
                    case &amp;#34;-&amp;#34;:
                        ret = b - a;
                    case &amp;#34;*&amp;#34;:
                        ret = a * b;
                    case &amp;#34;/&amp;#34;:
                        ret = b / a;
             
                    default:
                        ret = 0
                }
                stack.push(ret)
            }
        }
        return stack.top.next!.data!
    }
    
    func isInt(string: String) -&amp;gt; Bool {
        let scan: Scanner = Scanner(string: string)
        var val:Int = 0
        return scan.scanInt(&amp;amp;val) &amp;amp;&amp;amp; scan.isAtEnd
    }
}

let test1 = [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;+&amp;#34;,&amp;#34;2&amp;#34;,&amp;#34;*&amp;#34;,&amp;#34;2&amp;#34;,&amp;#34;-&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;/&amp;#34;]
let test2 = [&amp;#34;2&amp;#34;,&amp;#34;9&amp;#34;,&amp;#34;3&amp;#34;,&amp;#34;/&amp;#34;,&amp;#34;+&amp;#34;,&amp;#34;4&amp;#34;,&amp;#34;-&amp;#34;]
let exp = ExpressionOperation()
exp.input(expression: test)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;中缀表达式求值&#34;&gt;中缀表达式求值&lt;/h3&gt;

&lt;p&gt;基本策略:将中缀表达式转换为后缀表示式,然后求值&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从头到尾读取中缀表达式的每个元素&lt;/li&gt;
&lt;li&gt;运算数:直接输出&lt;/li&gt;
&lt;li&gt;左括号:入栈&lt;/li&gt;
&lt;li&gt;右括号:将栈顶的运算符出栈并输出,直到遇到左括号(出栈,不输出)&lt;/li&gt;
&lt;li&gt;运算符:

&lt;ul&gt;
&lt;li&gt;若优先级大于栈顶运算符时,则入栈&lt;/li&gt;
&lt;li&gt;若优先级小于栈顶运算符时,将栈顶运算符出栈并输出,再比较新的栈顶运算符,直到该运算符优先级大于栈顶运算符为止,然后该运算符入栈&lt;/li&gt;
&lt;li&gt;若对各个元素处理完毕,则把堆栈中留存的运算符一并输出&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;其他应用&#34;&gt;其他应用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;函数调用及递归实现&lt;/li&gt;
&lt;li&gt;深度优先搜索&lt;/li&gt;
&lt;li&gt;回溯算法&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>队列</title>
      <link>https://rangerzz.github.io/post/10/</link>
      <pubDate>Tue, 09 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://rangerzz.github.io/post/10/</guid>
      
        <description>

&lt;h2 id=&#34;队列&#34;&gt;队列&lt;/h2&gt;

&lt;h3 id=&#34;队列的抽象数据类型描述&#34;&gt;队列的抽象数据类型描述&lt;/h3&gt;

&lt;p&gt;具有一定操作约束的线性表,只能在一端插入,而在另一端删除&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据插入:入队&lt;/li&gt;
&lt;li&gt;数据删除:出队&lt;/li&gt;
&lt;li&gt;先进先出(FIFO)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;类型名称-队列-queue&#34;&gt;类型名称:队列(Queue)&lt;/h4&gt;

&lt;h4 id=&#34;数据对象集-一个有0个或多个元素的有穷线性表&#34;&gt;数据对象集:一个有0个或多个元素的有穷线性表&lt;/h4&gt;

&lt;h4 id=&#34;操作集&#34;&gt;操作集&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;创建空队列&lt;/li&gt;
&lt;li&gt;判读队列是否已满&lt;/li&gt;
&lt;li&gt;插入元素&lt;/li&gt;
&lt;li&gt;队列是否为空&lt;/li&gt;
&lt;li&gt;将队列头部元素删除并返回&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;队列的顺序存储实现&#34;&gt;队列的顺序存储实现&lt;/h2&gt;

&lt;p&gt;队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量front以及一个记录队列尾元素位置的变量rear组成&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;swift的特性不适合描述一个数组实现的队列,故采用老师提供的C语音实现

#define MaxSize &amp;lt;储存数据元素的最大个数&amp;gt; 
struct QNode {
    ElementType Data[ MaxSize ]; 
    int rear;
    int front;
};
typedef struct QNode *Queue;

void AddQ( Queue PtrQ, ElementType item) {
    if ( (PtrQ-&amp;gt;rear+1) % MaxSize == PtrQ-&amp;gt;front ) { 
        printf(“队列满”);
        return;
    }
    PtrQ-&amp;gt;rear = (PtrQ-&amp;gt;rear+1)% MaxSize; 
    PtrQ-&amp;gt;Data[PtrQ-&amp;gt;rear] = item;
}

ElementType DeleteQ ( Queue PtrQ ) {
    if ( PtrQ-&amp;gt;front == PtrQ-&amp;gt;rear ) { 
        printf(“队列空”);
        return ERROR;
    } else {
        PtrQ-&amp;gt;front = (PtrQ-&amp;gt;front+1)% MaxSize; 
        return PtrQ-&amp;gt;Data[PtrQ-&amp;gt;front];
    } 
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;队列的链式存储实现&#34;&gt;队列的链式存储实现&lt;/h2&gt;

&lt;p&gt;队列的链式存储结构也可以用一个单链表实现,插入和删除操作分别在链表的两头进行.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;75
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;class QueueNode&amp;lt;T:Hashable&amp;gt; : Equatable {
    static func == (lhs: QueueNode&amp;lt;T&amp;gt;, rhs: QueueNode&amp;lt;T&amp;gt;) -&amp;gt; Bool {
        if lhs.data == rhs.data &amp;amp;&amp;amp; lhs.next == rhs.next {
            return true
        }
        else {
            return false
        }
    }
    
    var data : T?
    var next : QueueNode&amp;lt;T&amp;gt;?
    
}

class Queue&amp;lt;T:Hashable&amp;gt; {
    var rear : QueueNode&amp;lt;T&amp;gt;?
    var front : QueueNode&amp;lt;T&amp;gt;?
    
    func isEmpty() -&amp;gt; Bool {
        if rear == nil &amp;amp;&amp;amp; front == nil {
            return true
        }
        else {
            return false;
        }
    }
    
    func add(item:T) -&amp;gt; Void {
        let node = QueueNode&amp;lt;T&amp;gt;()
        node.data = item
        
        if isEmpty() {
            rear = node
            front = node
            return
        }
        
        rear!.next = node
        rear = node
    }
    
    func delete() -&amp;gt; T? {
        if isEmpty() {
            print(&amp;#34;队列空&amp;#34;)
            return nil
        }
        
        if front == rear {
            let data = front!.data
            front = nil
            rear = nil
            return data
        }
        
        let data = front?.data
        front = front?.next
        return data
    }
}

let q = Queue&amp;lt;String&amp;gt;()
q.add(item: &amp;#34;aaaa&amp;#34;)
q.add(item: &amp;#34;bbbb&amp;#34;)
print(q.rear?.data)
print(q.front?.data)
print(q.delete())
print(q.rear?.data)
print(q.front?.data)
q.add(item: &amp;#34;cccc&amp;#34;)
print(q.rear?.data)
print(q.front?.data)
print(q.delete())
print(q.delete())
print(q.delete())&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>线性表</title>
      <link>https://rangerzz.github.io/post/8/</link>
      <pubDate>Mon, 08 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://rangerzz.github.io/post/8/</guid>
      
        <description>

&lt;h2 id=&#34;线性表&#34;&gt;线性表&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;线性表(Linear List)&lt;/strong&gt;:由同类型数据元素构成有序序列的线性结构,一对一&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;表中元素的个数称为线性表的长度&lt;/li&gt;
&lt;li&gt;线性表没有元素时称为空表&lt;/li&gt;
&lt;li&gt;表起始位置称为表头,结束位置称为表尾&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;线性表的抽象数据类型描述&#34;&gt;线性表的抽象数据类型描述&lt;/h2&gt;

&lt;h3 id=&#34;类型名称-线性表-list&#34;&gt;类型名称:线性表(List)&lt;/h3&gt;

&lt;h3 id=&#34;数据对象集-线性表是n-n-0-个元素构成的有序序列-a1-a2-an&#34;&gt;数据对象集:线性表是n(n&amp;gt;=0)个元素构成的有序序列(a1,a2,&amp;hellip;.an)&lt;/h3&gt;

&lt;h3 id=&#34;操作集&#34;&gt;操作集&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;初始化一个空线性表&lt;/li&gt;
&lt;li&gt;是否空表&lt;/li&gt;
&lt;li&gt;查找

&lt;ul&gt;
&lt;li&gt;根据key返回value&lt;/li&gt;
&lt;li&gt;根据value返回第一次出现此value的key&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;插入&lt;/li&gt;
&lt;li&gt;删除&lt;/li&gt;
&lt;li&gt;表长&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;线性表的实现方式&#34;&gt;线性表的实现方式&lt;/h2&gt;

&lt;h3 id=&#34;线性表的顺序存储实现-数组&#34;&gt;线性表的顺序存储实现(数组)&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 线性结构的数组实现
struct LinearListUseArray&amp;lt;T&amp;gt; where T : Equatable, T : Any {
    var data : [T]?
    var last : Int// 最后一个下标
    
    init() {
        data = nil
        last = -1
    }
    
    func isEmpty() -&amp;gt; Bool {
        return last &amp;lt; 0
    }
    
    func key(for value:T) -&amp;gt; Int {
        if isEmpty() {
            return NSNotFound
        }
        if let array = data {
            for i in 0..&amp;lt;array.count {
                if array[i] == value {
                    return i
                }
            }
            return NSNotFound
        }
        else {
            return NSNotFound
        }
    }
    
    func value(for key:Int) -&amp;gt; T? {
        if isEmpty() || key &amp;lt; 0 || key &amp;gt; last {
            return nil
        }
        return data?[key]
    }
    
    mutating func insert(value v:T, at i:Int) -&amp;gt; Bool {
        if i&amp;lt;0 || i &amp;gt; last || isEmpty() {
            return false
        }
        data?.insert(v, at: i)
        last += 1
        return true;
    }
    
    mutating func delete(key i:Int) -&amp;gt; T? {
        if i&amp;lt;0 || i &amp;gt; last || isEmpty()  {
            return nil
        }
        let v = data?.remove(at: i)
        last -= 1
        return v
    }
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;线性表的链式存储实现-链表&#34;&gt;线性表的链式存储实现(链表)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;不要求逻辑上相邻的元素在物理存储上也相邻&lt;/li&gt;
&lt;li&gt;插入,删除不需要移动元素,只需要修改链&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;83
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;class LinearListNode&amp;lt;T: Hashable&amp;gt; {
    var data : T?
    var next : LinearListNode?
    init(data:T?) {
        self.data = data
    }
}

class LinearList&amp;lt;T : Hashable&amp;gt; {
    var head : LinearListNode&amp;lt;T&amp;gt;?
    init() {
        head = nil
    }
    
    func length() -&amp;gt; Int {
        var length = 0, n = head
        while (n != nil) {
            n = n!.next
            length += 1
        }
        return length
    }
    
    func findNode(number:Int) -&amp;gt; LinearListNode&amp;lt;T&amp;gt;? {
        var i = 0, n = head
        while n != nil &amp;amp;&amp;amp; i &amp;lt; number {
            n = n!.next
            i += 1
        }
        if i == number {
            return n
        }
        else {
            return nil
        }
    }
    
    func findNode(data:T) -&amp;gt; LinearListNode&amp;lt;T&amp;gt;? {
        var n = head
        while n != nil {
            if n!.data == data {
                return n
            }
            n = n!.next
        }
        return nil
    }
    
    func insert(value:T, at i:Int) -&amp;gt; Void {
        let node = LinearListNode(data: value);
        if i == 0 {
            node.next = head
            head = node;
            return
        }
        
        let lastNode = findNode(number: i - 1)
        node.next = lastNode?.next
        lastNode?.next = node
    }
    
    func delete(at i:Int) -&amp;gt; T?{
        var temp : T? = nil
        if i == 0 {
            temp = head?.data
            head = head?.next
            return temp
        }
        
        let n = findNode(number: i - 1)
        if n == nil || n!.next == nil {
            return nil
        }
        temp = n!.next!.data
        n!.next = n!.next!.next
        return temp
    }
}

let list = LinearList&amp;lt;String&amp;gt;()
list.insert(value: &amp;#34;aaa&amp;#34;, at: 0)
list.insert(value: &amp;#34;bbb&amp;#34;, at: 1)
list.insert(value: &amp;#34;ccc&amp;#34;, at: 2)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;广义表&#34;&gt;广义表&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;广义表是线性表的推广&lt;/li&gt;
&lt;li&gt;线性表中,n个元素都是单元素&lt;/li&gt;
&lt;li&gt;广义表中,元素不仅可以是单元素也可以是另一个广义表&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;typedef struct GNode *GList; 
struct GNode{
    int Tag; /*标志域:0表示结点是单元素，1表示结点是广义表 */
    union { /*子表指针域Sublist与单元素数据域Data复用，即共用存储空间*/
        ElementType Data;
        GList SubList;
    } URegion;
    GList Next; /* 指向后继结点 */
};&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;多重链表&#34;&gt;多重链表&lt;/h2&gt;

&lt;p&gt;链表中的节点可能同时隶属于多个链&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多重链表中的节点的指针域会有多个,例如广义表中的Next和SubList两个指针域&lt;/li&gt;
&lt;li&gt;但包含两个指针域的链表不一定是多重链表,如双向链表不是多重链表&lt;/li&gt;
&lt;li&gt;多重链表有广泛的用途,如树,图这种复杂度数据结构都可以用多重链表的方式实现存储&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>数据结构与算法基本概念</title>
      <link>https://rangerzz.github.io/post/7/</link>
      <pubDate>Thu, 04 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://rangerzz.github.io/post/7/</guid>
      
        <description>

&lt;p&gt;大学时学习的数据结构课程,只剩下零星的记忆,在工作中用到时候,对一些概念定义总是似曾相识却又不甚透彻,所以决心重新系统的学习一下数据结构与算法这门课程.
本系列文章是我在学习&lt;strong&gt;中国大学MOOC网中浙江大学陈越、何钦铭老师的《数据结构》&lt;/strong&gt;这门课程的学习笔记.&lt;/p&gt;

&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;“数据结构(data structure)是计算机中存储、组织
数据的方式。”-中文维基百科&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;解决问题方法的效率,和数据的组织方式有关.&lt;/li&gt;
&lt;li&gt;解决问题方法的效率,和空间的利用效率有关.&lt;/li&gt;
&lt;li&gt;解决问题方法的效率,和算法的巧妙程度有关.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;什么是数据结构&#34;&gt;什么是数据结构&lt;/h3&gt;

&lt;h4 id=&#34;数据对象在计算机中的组织方式&#34;&gt;数据对象在计算机中的组织方式&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;逻辑结构&lt;/li&gt;
&lt;li&gt;物理存储结构&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;数据对象必定与一系列加在其上的操作相关联&#34;&gt;数据对象必定与一系列加在其上的操作相关联&lt;/h4&gt;

&lt;h4 id=&#34;完成这些操作所用的方法就是-算法&#34;&gt;完成这些操作所用的方法就是&lt;strong&gt;算法&lt;/strong&gt;&lt;/h4&gt;

&lt;h3 id=&#34;抽象数据类型-abstract-data-type&#34;&gt;抽象数据类型(Abstract Data Type)&lt;/h3&gt;

&lt;h4 id=&#34;数据类型&#34;&gt;数据类型&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;数据对象集&lt;/li&gt;
&lt;li&gt;数据集合相关联的操作集&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;抽象&#34;&gt;抽象&lt;/h4&gt;

&lt;p&gt;描述数据类型的方法不依赖于具体实现
* 与存放数据的机器无关
* 与数据存储的物理结构无关
* 与实现操作的算法和编程语言无关&lt;/p&gt;

&lt;h2 id=&#34;算法-algorithm&#34;&gt;算法(Algorithm)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一个有限指令集&lt;/li&gt;
&lt;li&gt;接受一些输入(有些情况不需要输入)&lt;/li&gt;
&lt;li&gt;产生输出&lt;/li&gt;
&lt;li&gt;一定在有限步骤后终止&lt;/li&gt;
&lt;li&gt;每一条指令必须

&lt;ul&gt;
&lt;li&gt;有充分明确的目标,不可以有歧义&lt;/li&gt;
&lt;li&gt;计算机能处理的范围之内&lt;/li&gt;
&lt;li&gt;描述应不依赖于任何一种计算机语言以及具体的实现手段
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;空间复杂图s-n&#34;&gt;空间复杂图S(n)&lt;/h3&gt;

&lt;p&gt;根据算法写成的程序在执行时占用存储单元的长度.这个长度往往与输入数据的规模有关.空间复杂度过高的算法可能导致使用的内存超限,造成程序的异常中断.&lt;/p&gt;

&lt;h3 id=&#34;时间复杂度t-n&#34;&gt;时间复杂度T(n)&lt;/h3&gt;

&lt;p&gt;根据算法写成的程序在执行时耗费时间的长度.这个长度往往与输入数据的规模有关.时间复杂度过高的低效算法可能需要很久也等不到运行结果.
&lt;img src=&#34;media/15619508314149/15622290928478.jpg&#34; alt=&#34;-w474&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;复杂度分析&#34;&gt;复杂度分析&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;若两段算法分别有复杂度T1(n) = O(f1(n)) 和T2(n) = O(f2(n))，则

&lt;ul&gt;
&lt;li&gt;T1(n) + T2(n) = max( O(f1(n)), O(f2(n)) )&lt;/li&gt;
&lt;li&gt;T1(n) * T2(n) = O( f1(n) * f2(n) )&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;若T(n)是关于n的k阶多项式，那么T(n)=Θ(nk)&lt;/li&gt;
&lt;li&gt;一个for循环的时间复杂度等于循环次数乘以循环体
代码的复杂度&lt;/li&gt;
&lt;li&gt;一个for循环的时间复杂度等于循环次数乘以循环体
代码的复杂度&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;最大子列和问题&#34;&gt;最大子列和问题&lt;/h2&gt;

&lt;p&gt;给定N个整数的序列{ A1, A2, &amp;hellip;, AN},求最大连续子列的和&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func SublistMaxSum(list:[Int])-&amp;gt;Int {
    var sum = 0, max = 0
    for item in list {
        sum += item;
        if sum &amp;gt; max {
            max = sum
        }
        else if sum &amp;lt; 0 {
            sum = 0
        }
    }
    return max
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>正则表达式</title>
      <link>https://rangerzz.github.io/post/6/</link>
      <pubDate>Fri, 15 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://rangerzz.github.io/post/6/</guid>
      
        <description>

&lt;h2 id=&#34;js中正则表达式两种创建方式&#34;&gt;JS中正则表达式两种创建方式:&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;字面量: &lt;code&gt;let reg = /abc/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;RegExp构造函数: &lt;code&gt;let reg = new RegExp(&#39;abc&#39;)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;修饰符&#34;&gt;修饰符&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;i&lt;/code&gt;:忽略大小写&lt;/p&gt;

&lt;p&gt;&lt;code&gt;g&lt;/code&gt;:全局匹配&lt;/p&gt;

&lt;p&gt;&lt;code&gt;m&lt;/code&gt;:多行匹配&lt;/p&gt;

&lt;h2 id=&#34;元字符&#34;&gt;元字符&lt;/h2&gt;

&lt;p&gt;大多数字符在正则表达式中只是是字面意思如/a/匹配a,这类字符叫做&lt;strong&gt;字面量字符&lt;/strong&gt;
除了字面量字符,还有一部分特殊字符,不代表其字面意思,叫做&lt;strong&gt;元字符&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;字符类&#34;&gt;字符类&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;.&lt;/code&gt;:点字符匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。
&lt;em&gt;注意，对于码点大于0xFFFF的 Unicode 字符，点字符不能正确匹配，会认为这是两个字符。&lt;/em&gt;
&lt;code&gt;|&lt;/code&gt;:或关系&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[a-z]&lt;/code&gt;:表示26个小写字母任意一个都可以匹配&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[0-9]&lt;/code&gt;:表示数字0-9任意一个数字可以匹配&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[a-zA-Z0-9]&lt;/code&gt;:表示大小写a-z0-9任意一个可以匹配&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[^0-9]&lt;/code&gt;:表示非0-9的任意一个字符可以匹配&lt;/p&gt;

&lt;h3 id=&#34;特殊字符&#34;&gt;特殊字符&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;\w&lt;/code&gt;:匹配字母数字下划线_ ,相当于&lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\W&lt;/code&gt;:匹配非字母数字下划线_ ,相当于&lt;code&gt;[^a-zA-Z0-9_]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\d&lt;/code&gt;:匹配数字,相当于&lt;code&gt;[0-9]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\D&lt;/code&gt;:匹配数字,相当于&lt;code&gt;[^0-9]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\s&lt;/code&gt;:匹配空格（包括换行符、制表符、空格符等,相等于[ \t\r\n\v\f]&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\S&lt;/code&gt;:匹配非空格的字符，相当于[^ \t\r\n\v\f]&lt;/p&gt;

&lt;h3 id=&#34;重复字符&#34;&gt;重复字符&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;{m,n}&lt;/code&gt;:匹配m-n个,包含m,n&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{m}&lt;/code&gt;:匹配m个,限定m个&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{m,}&lt;/code&gt;:匹配m个或m个以上&lt;/p&gt;

&lt;h3 id=&#34;量词&#34;&gt;量词&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;*&lt;/code&gt;:匹配0个,1个或多个&lt;/p&gt;

&lt;p&gt;&lt;code&gt;+&lt;/code&gt;:匹配1个或者多个&lt;/p&gt;

&lt;p&gt;&lt;code&gt;?&lt;/code&gt;:匹配0个或者1个
&lt;strong&gt;非贪婪模式:量词符后加&lt;code&gt;?&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;位置字符&#34;&gt;位置字符&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;/^[0-9]/&lt;/code&gt;:&lt;code&gt;/^&lt;/code&gt;以0-9开始的任意一个数字可以匹配&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/[a-z]$/&lt;/code&gt;:&lt;code&gt;$/&lt;/code&gt;以a-z任意小写字母结尾的可以匹配&lt;/p&gt;

&lt;h3 id=&#34;分组&#34;&gt;分组&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;()&lt;/code&gt;:分组&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(?:[a-z])&lt;/code&gt;:非捕获性分组&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(a?(b?))&lt;/code&gt;:嵌套分组,从外向内获取&lt;/p&gt;

&lt;p&gt;&lt;code&gt;m(?=n)&lt;/code&gt;:先行断言匹配,m只有在n前面才匹配&lt;/p&gt;

&lt;p&gt;&lt;code&gt;m(?!n)&lt;/code&gt;:先行否定断言匹配,m只有不在n前面才匹配&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>2018年工作总结和思考</title>
      <link>https://rangerzz.github.io/post/5/</link>
      <pubDate>Tue, 25 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://rangerzz.github.io/post/5/</guid>
      
        <description>

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;今年春节后跳出了之前的工作内容,不再是重复性的一直做类似的事情.接手了一个新项目,并且独自负责iOS端的开发,期间陆续迭代调整方向持续到了年底.
18年初,视频答题撒币的火热,市面上诞生了许多大厂小厂的产品,我司也想结合公司业务和答题的场景,推出一款产品试水,但是随着政策出台,视听许可证的强制要求,视频直播答题的想法破灭.当时微信小程序也是热门话题,最终结合先装,我司决定开发一个短视频答题小程序.由我&lt;strong&gt;跟进&lt;/strong&gt;开发iOS端.&lt;/p&gt;

&lt;p&gt;答题形式从初版的边播视频边答题,陆续改版为先播视频再答题.答题方式也发展出定时答(每天所有用户同一时刻开始答题)和即时答(用户随时可以开始答题)两种.期间陆续添加用户系统,用户出题,积分兑换和提现等其他的常规功能.&lt;/p&gt;

&lt;p&gt;直到九月份,放弃答题相关业务的开发,转而结合我司核心业务.开发基于ReplayKit的录屏直播功能,期间遇到许多问题和挑战,之前写过&lt;a href=&#34;https://rangerzz.github.io/post/3/&#34;&gt;ReplayKit简介&lt;/a&gt;&lt;!--以及[录屏直播实现](#)(即将发布)--&gt;可以参考.&lt;/p&gt;

&lt;h2 id=&#34;思考&#34;&gt;思考&lt;/h2&gt;

&lt;h3 id=&#34;从app主导到跟进小程序&#34;&gt;从App主导到跟进小程序&lt;/h3&gt;

&lt;p&gt;之前的工作经历都是To C面向用户的产品,到现在公司后,公司主要做的是To B面向客户的业务,我的日常工作也从原来的开发主要产品App转变为现在的开发&lt;strong&gt;辅助&lt;/strong&gt;To B业务的工具,在工作中调整开发节奏和状态,也慢慢适应了.但是没想到沉寂了许久的微信小程序,在2017.12.28日,微信推出小游戏并发布&lt;strong&gt;&amp;lt;跳一跳&amp;gt;&lt;/strong&gt;后再次引发热议,而且这次不仅仅是热议,还调动了许多开发者的热情,许多&lt;strong&gt;公司与个人参与进来开发功能丰富的小程序&lt;/strong&gt;,我司也结合了直播答题的风靡和&lt;strong&gt;小程序的快速开发,微信的巨大流量和爆发式传播速度的优势&lt;/strong&gt;决定开发答题小程序.由我跟进小程序的进度开发iOS端,为什么说跟进呢?因为本次开发,从需求制定,到产品设计,到业务实现,完全是小程序或者说web式的,比如产品设计,我第一次开发像网页一样布局和交互的应用,更是第一次用web端的设计图来适配iOS端.
但是小程序显而易见的好处:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;开发迭代周期短.这点特别令我惊讶(也有以小程序为主导做产品设计的因素),小程序从开发到审核上线的整体速度都快于App,这也带来一个好处,当我需要用接口的时候,后端同事和小程序端同事调试都已经调试好了😊.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;快速的用户增长.得力于小程序在微信内便捷的传播方式,仅仅是通过朋友圈分享,我们就获得了大量用户,当然我们产品本身带有激励属性,也激发了用户传播的积极性.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;答题的一些思考&#34;&gt;答题的一些思考&lt;/h3&gt;

&lt;h4 id=&#34;答题的火热与沉寂&#34;&gt;答题的火热与沉寂&lt;/h4&gt;

&lt;p&gt;2018年年初,视频在线答题,&lt;strong&gt;撒币&lt;/strong&gt;等关键词瞬间充斥在各种媒体,可谓是全民参与,当时午餐时间同事都会准时守着手机参与其中.当时不论是大厂,视频直播行业相关公司还是无关公司,都要分一杯羹,数十款视频在线答题项目纷纷上线,大有再现16年手机直播行业的架势,但最终在视听许可证的政策下瞬间沉寂,对此不做评价,仅记录一下我的思考.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;技术方案的服务商可谓拥有最敏锐的行业嗅觉,当我想了解相关技术方案的时候,看到了阿里的整套直播答题解决方案.可以想象无论直播答题平台发了多少奖金,吸引了多少用户,烧了多少资金,提供解决方案的服务商,最终都会赚的盆满钵满.当时每天都会上线数款同类应用,也有服务商很大的功劳.结合鹅厂最近提出的着重发展To B业务,深深感受到To B业务的魅力和潜力.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;直播答题撒币当时是一个很好很热的模式,由于三方服务的完善也是没有很大的技术门槛,所以大小厂都推出相关功能,记得有UC浏览器推出的PK答题等.给我印象最为深刻的是答题作弊直播,就是在答题平台开始同步答题的同时,有些应用内会推出一个直播频道,有所谓的&amp;rdquo;专家&amp;rdquo;告诉大家该题选什么(只是正确率略微高一些,并不能保证全对),蹭热度的方式五花八门.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用户激励.当时的盛况可谓是全名参与,每场答题都有数十万人参加,其实最终答题成功的奖金少则几角多则几元,但是碎片化时间,一场答题最长不过半小时,用户参与的意愿还是很高的.所以只要有钱有激励,再加上合适的推广宣传方式,可以快速的获取到海量用户.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;答题业务的迭代历程&#34;&gt;答题业务的迭代历程&lt;/h4&gt;

&lt;p&gt;由于我司属于广告行业,所以领导结合答题的激励形式,做一个短视频(广告片)答题构思,多样化广告投放形式.答题形式经历了三个过程&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;最初的形式是边播视频边出题边答题同时进行.上线一段时间后发现,由于视频库的数量,用户可以做到看到视频开头,就知道视频大概内容,并且播放视频同时显示题目,用户可以做到定位答案在视频哪一个时间点,更有甚者可以做到不看视频直接提交答案.新老用户感受到的难度偏差导致不甚公平,老用户更容易通关,而新用户体验不佳.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;之后迭代新版,做成了将所有短视频播放一遍才会开始出题,并且不再播放视频,避免视频和题目同时出现.这样做首先客观上强迫用户需要首先看完每段视频,其次由于不是视频和题目同时出现,用户对答案的预见性降低,主观上也会更加认真观看视频,留意更多视频细节.上线一段时间后新老用户通关率明显降低.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后将答题分为定时答和即时答.首先添加即时答,用户只要有门票(激励用户传播和日活,邀请签到送门票),就可以随时开启答题,答题使用上面提到的形式,通关奖励为瓜分次数.其次定时答修改为将视频提前公布出来,新老用户都随时可看,定时答开始后只显示文字题目.保证了公平性也增加了视频观看次数,通关奖励同样是瓜分次数.至于奖金,则由本场答题产生的瓜分次数和之前即时答产生的瓜分次数叠加后均分,用户获得相应瓜分次数的奖金,获得奖金金额额多样化,更有趣味性.所以做到了在没有增加总奖金的前提下,增加了用户粘性,活跃度.更有用户上传视频和出题等功能,丰富题库.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>iOS常见权限授权</title>
      <link>https://rangerzz.github.io/post/4/</link>
      <pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://rangerzz.github.io/post/4/</guid>
      
        <description>

&lt;h2 id=&#34;权限状态-authorizationstatus&#34;&gt;权限状态 AuthorizationStatus&lt;/h2&gt;

&lt;p&gt;权限状态枚举,API比较统一,都是相关框架前缀+固定描述拼接,大致如下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;AuthorizationStatusNotDetermined&lt;/code&gt;代表还未向用户进行过询问授权,一般为应用新装或第一次请求对应权限.此时可以主动向用户请求授权.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;AuthorizationStatusRestricted&lt;/code&gt;代表对应权限被拒绝,并且用户无权改变权限状态,例如文档中举例家长控制这种情况.因此当做未授权的情况处理处理.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;AuthorizationStatusDenied&lt;/code&gt;代表被用户拒绝.此时可以提醒用户该权限无法访问,需要去设置中打开.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;AuthorizationStatusAuthorized&lt;/code&gt;代表已经获取对应权限.此时可以访问相关数据和使用相关功能.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;相册权限&#34;&gt;相册权限&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 导入框架
#import &amp;lt;Photos/Photos.h&amp;gt;

// 当前授权状态 
// status就对应上面提到的枚举以及对应含义
PHAuthorizationStatus status = [PHPhotoLibrary authorizationStatus];

// 主动请求授权
if (status == PHAuthorizationStatusNotDetermined) {
        [PHPhotoLibrary requestAuthorization:^(PHAuthorizationStatus status) {
            if (status == PHAuthorizationStatusAuthorized) {
                // 已授权 可以访问相册等操作
            }
            else {
                // 未授权 提示用户
            }
        }];
    }&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;相机-麦克风权限&#34;&gt;相机 麦克风权限&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;#import &amp;lt;AVFoundation/AVFoundation.h&amp;gt;

// AVMediaTypeVideo 相机权限
// AVMediaTypeAudio 麦克风权限

// 当前授权状态
AVAuthorizationStatus status = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo];

// 主动请求授权
if (status == AVAuthorizationStatusNotDetermined) {
        [AVCaptureDevice requestAccessForMediaType:AVMediaTypeVideo completionHandler:^(BOOL granted) {
            // granted == YES 已授权
        }];
    }&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;推送&#34;&gt;推送&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;#import &amp;lt;UserNotifications/UserNotifications.h&amp;gt;

// 获取当前授权状态
[[UNUserNotificationCenter currentNotificationCenter] getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) {
        // 当前授权状态
        UNAuthorizationStatus unStatus = settings.authorizationStatus;
        
        if (unStatus == UNAuthorizationStatusAuthorized) {
            // 已授权
        }
        else {
        // 请求授权
            [[UNUserNotificationCenter currentNotificationCenter] requestAuthorizationWithOptions:UNAuthorizationOptionAlert | UNAuthorizationOptionSound |UNAuthorizationOptionBadge completionHandler:^(BOOL granted, NSError * _Nullable error) {
                // granted == YES 已授权
            }];
        }
    }];&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;日历&#34;&gt;日历&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;#import &amp;lt;EventKit/EventKit.h&amp;gt;

// 当前授权状态 
//EKEntityTypeEvent日历 EKEntityTypeReminder提醒事项
EKAuthorizationStatus status = [EKEventStore authorizationStatusForEntityType:EKEntityTypeEvent];
    
// 未询问
    if (status == EKAuthorizationStatusNotDetermined) {
    // 请求授权
        [[[EKEventStore alloc] init] requestAccessToEntityType:EKEntityTypeEvent completion:^(BOOL granted, NSError * _Nullable error) {
            // granted == YES 已授权
        }];
    }&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;联系人&#34;&gt;联系人&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;#import &amp;lt;Contacts/Contacts.h&amp;gt;

// 当前授权状态
CNAuthorizationStatus status = [CNContactStore authorizationStatusForEntityType:CNEntityTypeContacts];
// 未询问
    if (status == CNAuthorizationStatusNotDetermined) {
    // 请求授权
        [[[CNContactStore alloc] init] requestAccessForEntityType:CNEntityTypeContacts completionHandler:^(BOOL granted, NSError * _Nullable error) {
            // granted == YES 已授权
        }];
    }&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;定位&#34;&gt;定位&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;#import &amp;lt;CoreLocation/CoreLocation.h&amp;gt;

// 需要引用 CLLocationManager
@property (nonatomic, strong) CLLocationManager *locationManager;

// 获取授权状态
CLAuthorizationStatus status = [CLLocationManager authorizationStatus];
    // 未授权
    if (status == kCLAuthorizationStatusNotDetermined) {
    // 请求一直定位
        [self.locationManager requestAlwaysAuthorization];
    // 请求使用时定位
        [self.locationManager requestWhenInUseAuthorization];
    }

// CLLocationManagerDelegate
// 定位权限变化的回调方法
- (void)locationManager:(CLLocationManager *)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status {
    
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;zrautorizationmanager&#34;&gt;ZRAutorizationManager&lt;/h2&gt;

&lt;p&gt;封装了以上所有权限的状态和授权,统一API,一行代码获取状态和请求授权.并且系统API的授权请求结果回调线程一般不是主线程,使用&lt;strong&gt;ZRAutorizationManager&lt;/strong&gt;,可以在系统API线程或在&lt;strong&gt;主线程回调授权结果&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 一个枚举统一处理授权状态
typedef NS_ENUM(NSUInteger, ZRAutorizationStatus) {
    ZRAutorizationStatusNotDetermined,// 用户还未选择是否允许授权 可以代表第一次询问
    ZRAutorizationStatusDenied,// 拒绝授权 包括 Restricted &amp;amp; Denied
    ZRAutorizationStatusAuthorized,// 已授权
    
    ZRAutorizationStatusUnknow,// 未知状态
};

// 获取授权状态
+ (ZRAutorizationStatus)autorizationStatusForType:(ZRAutorizationType)type;

// 请求授权后结果的回调是系统API回调的线程,一般不是主线程
+ (void)requestAuthorization:(ZRAutorizationType)type grantedBlock:(void (^)(BOOL granted))grantedBlock;

// 请求授权后结果的回调是主线程
+ (void)requestAuthorization:(ZRAutorizationType)type grantedBlock:(void (^)(BOOL granted))grantedBlock;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/RangerZz/ZRAutorizationManager&#34;&gt;下载查看github&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>ReplayKit 2录屏直播</title>
      <link>https://rangerzz.github.io/post/3/</link>
      <pubDate>Tue, 23 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://rangerzz.github.io/post/3/</guid>
      
        <description>

&lt;h2 id=&#34;概览&#34;&gt;概览&lt;/h2&gt;

&lt;p&gt;iOS 11新添加了用户从控制中心开启全局的录屏功能(在此之前只能实现应用内录制),这个功能和API(ReplayKit 2)的添加,使得录屏直播以及其他录屏相关的玩法拥有了无限可能.
刚好近一个月我司产品添加相关功能,并由我完成,从查阅相关文档到添加录屏直播的第一版App上线,用了2周多时间,期间尝试了阿里和腾讯的SDK,下面就回顾一下这段时间的学习和成长.&lt;/p&gt;

&lt;h2 id=&#34;介绍extension&#34;&gt;介绍Extension&lt;/h2&gt;

&lt;p&gt;Xcode 9中,添加了&amp;rsquo;Broadcast Upload Extension&amp;rsquo; 和 &amp;lsquo;Broadcast Setup UI Extension&amp;rsquo;,用来实现相关功能,需要在File -&amp;gt; New -&amp;gt; Target中创建他们.&lt;/p&gt;

&lt;h3 id=&#34;broadcast-upload-extension&#34;&gt;Broadcast Upload Extension&lt;/h3&gt;

&lt;p&gt;最为核心的是&amp;rsquo;Broadcast Upload Extension&amp;rsquo;(后简称&amp;rsquo;Upload&amp;rsquo;),&amp;lsquo;Upload&amp;rsquo;中有多个系统回调方法,被用来告知录屏的开始,结束,暂停,恢复和采集到的音视频信息,大多数需求要通过该Extension实现.
&amp;lsquo;Upload&amp;rsquo;独立于App存在,运行时也不依赖App,是一个独立的进程,也就是说,用户并不需要启动App,就可以使用录屏功能,拥有便捷,轻量的特点.&lt;/p&gt;

&lt;h3 id=&#34;broadcast-setup-ui-extension&#34;&gt;Broadcast Setup UI Extension&lt;/h3&gt;

&lt;p&gt;在创建&amp;rsquo;Broadcast Upload Extension&amp;rsquo;时,Xcode会询问你是否需要一并创建&amp;rsquo;Broadcast Setup UI Extension&amp;rsquo;(后称&amp;rsquo;Setup UI&amp;rsquo;),此处可以选择不创建.
&amp;lsquo;Setup UI&amp;rsquo;在iOS11添加ReplayKit 2之前需要使用,在ReplayKit 2后,用户可以在控制中心发起全局的录屏功能后本插件就没那么重要了,由于本文主要介绍ReplayKit 2,故不做详细介绍了(我觉得这是个遗留问题,ReplayKit 2新特性更好更方便,完全可以替代之前的方案).&lt;/p&gt;

&lt;h2 id=&#34;实践实现&#34;&gt;实践实现&lt;/h2&gt;

&lt;h3 id=&#34;类和方法&#34;&gt;类和方法&lt;/h3&gt;

&lt;p&gt;创建&amp;rsquo;Upload&amp;rsquo;Target后,Xcode中会创建SampleHandler类,是RPBroadcastSampleHandler的子类,类中会有如下方法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;- (void)broadcastStartedWithSetupInfo:(NSDictionary&amp;lt;NSString *,NSObject *&amp;gt; *)setupInfo {
    // User has requested to start the broadcast. Setup info from the UI extension can be supplied but optional.
}

- (void)broadcastPaused {
    // User has requested to pause the broadcast. Samples will stop being delivered.
}

- (void)broadcastResumed {
    // User has requested to resume the broadcast. Samples delivery will resume.
}

- (void)broadcastFinished {
    // User has requested to finish the broadcast.
}

- (void)processSampleBuffer:(CMSampleBufferRef)sampleBuffer withType:(RPSampleBufferType)sampleBufferType {
    
    switch (sampleBufferType) {
        case RPSampleBufferTypeVideo:
            // Handle video sample buffer
            break;
        case RPSampleBufferTypeAudioApp:
            // Handle audio sample buffer for app audio
            break;
        case RPSampleBufferTypeAudioMic:
            // Handle audio sample buffer for mic audio
            break;
            
        default:
            break;
    }
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;根据方法名和注释,显而易见的知道这些方法分别在录屏开始,暂停,恢复,结束和音视频数据是被调用,并且会传递一些信息.
简单说一下这几个方法:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;-(void)broadcastStartedWithSetupInfo:(NSDictionary&amp;lt;NSString *,NSObject *&amp;gt; *)setupInfo;&lt;/code&gt;本方法在用户在 控制中心-&amp;gt;屏幕录制-&amp;gt;开始直播 点击321倒数结束后被调用.此处就可以开始初始化推流器,开启推流等工作,至于setupInfo,是&amp;rsquo;Setup UI&amp;rsquo;传递过来的一些初始化信息,当然如果不使用&amp;rsquo;Setup UI&amp;rsquo;,还是有多种方式传递&amp;rsquo;Upload&amp;rsquo;插件本身无法获取的信息.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-(void)broadcastFinished;&lt;/code&gt;本方法在用户 点击屏幕状态栏-&amp;gt;系统弹窗-&amp;gt;停止 后被调用.此处可以认为&amp;rsquo;Upload&amp;rsquo;插件进程即将被结束,需要做一些资源和内存释放等工作,然后插件进程结束.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-(void)processSampleBuffer:(CMSampleBufferRef)sampleBuffer withType:(RPSampleBufferType)sampleBufferType;&lt;/code&gt;本方法在&lt;code&gt;-(void)broadcastStartedWithSetupInfo:(NSDictionary&amp;lt;NSString *,NSObject *&amp;gt; *)setupInfo;&lt;/code&gt;被调用后,会不停的被调用,用来获取采集到的音视频信息,通过sampleBufferType区分.此处可以将音视频信息编码推流.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;消息传递与数据共享&#34;&gt;消息传递与数据共享&lt;/h3&gt;

&lt;p&gt;前文说的,&amp;lsquo;Upload&amp;rsquo;和App是相互独立的两个进程,&amp;lsquo;Upload&amp;rsquo;和App如何进行消息传递和数据共享呢,大致有如下几种方式:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;剪贴版:通过写入剪贴板,然后插件读取剪贴板传递一些简单数据,但是可靠性太差,可以作为一种辅助手段.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;UIPasteboard *paste = [UIPasteboard generalPasteboard];
paste.string = @&amp;#34;a&amp;#34;;// 写入
NSString *a = paste.string;// 读取&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;本地推送:插件可以发送本地通知,可以用来提示用户一些录屏事件,也可以提示用户点击通知,激活App做一些操作.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;- (void)sendLocalNotificationToHostAppWithTitle:(NSString *)title msg:(NSString *)msg userInfo:(NSDictionary *)userInfo {
    UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];
    UNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init];
    content.title = [NSString localizedUserNotificationStringForKey:title arguments:nil];
    content.body = [NSString localizedUserNotificationStringForKey:msg  arguments:nil];
    content.sound = [UNNotificationSound defaultSound];
    content.userInfo = userInfo;
    UNTimeIntervalNotificationTrigger* trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:0.1f repeats:NO];
    UNNotificationRequest* request = [UNNotificationRequest requestWithIdentifier:@&amp;#34;ReplayKitPush&amp;#34; content:content trigger:trigger];   
    [center addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) { 
    }];
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;通知:CFNotificationCenter可以发送跨进程的通知,用来做一些实时事件交互.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;CFNotificationCenterPostNotification(CFNotificationCenterGetDarwinNotifyCenter(),kDarvinNotificationNamePushStart,NULL,nil,YES);
CFNotificationCenterAddObserver(CFNotificationCenterGetDarwinNotifyCenter(), (__bridge const void *)(self), onDarwinReplayKitPushStart, kDarvinNotificationNamePushStart, NULL, CFNotificationSuspensionBehaviorDeliverImmediately);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;AppGroup:开启AppGroup后,同一AppGroup的成员,可以共享沙盒数据,也就是说,App可以读取&amp;rdquo;Upload&amp;rdquo;的录屏文件,&amp;ldquo;Upload&amp;rdquo;可以从App获取必要信息.AppGroup需要在 Capabilities -&amp;gt; AppGroup 中开启,App和插件都要打开,后会生成.entitlements文件,会有一个group.BundleIdentifier的标识.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:AppGroupId];// 共享的沙盒路径
NSUserDefaults *userDefault = [[NSUserDefaults alloc] initWithSuiteName:AppGroupId];// 共享的userDefault&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;注意线程问题&#34;&gt;注意线程问题&lt;/h3&gt;

&lt;p&gt;&amp;ldquo;Upload&amp;rdquo;中开始各种方法被调用的线程都不是主线程,所以要注意线程同步问题,并且实测如果强行回调到主线做一些耗时操作,会使&amp;rdquo;Upload&amp;rdquo;崩溃,所以非不得已(&amp;ldquo;Upload&amp;rdquo;也没有需要处理的UI事件),尽量使用当前线程,并且在开始和结束的方法中加同步锁.
以及如果开启NSTimer的话,由于不是主线程,记得开启当前线程的Runloop!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;- (void)setupTimerThread {
    if (self.tiemrThread.executing) {
        return;
    }
    
    self.tiemrThread = [[NSThread alloc] initWithTarget:self selector:@selector(startTimer) object:nil];
    self.tiemrThread.name = @&amp;#34;timerThread&amp;#34;;
    [self.tiemrThread start];
}

- (void)startTimer {
    @autoreleasepool {

        [self postPushStatus:ANPushHeartbeatStatusPushing];
        self.timer = [NSTimer timerWithTimeInterval:15 repeats:YES block:^(NSTimer * _Nonnull timer) {
        }];
    
        [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSDefaultRunLoopMode];

        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
    }
}

- (void)stopTimer {
    [self performSelector:@selector(invalidateTimer) onThread:self.tiemrThread withObject:nil waitUntilDone:NO];
}

- (void)invalidateTimer {
    if (self.timer) {
        [self.timer invalidate];
        self.timer = nil;
    }
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;以上是一些开发过程中学习到知识与坑点,如有问题,欢迎交流探讨.&lt;/p&gt;

&lt;h2 id=&#34;参考链接&#34;&gt;参考链接&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2018/601/&#34;&gt;Live Screen Broadcast with ReplayKit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2017/606&#34;&gt;What&amp;rsquo;s New with Screen Recording and Live Broadcast&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://cloud.tencent.com/document/product/454/7883&#34;&gt;腾讯云ReplayKit文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://help.aliyun.com/document_detail/45263.html?spm=a2c4g.11186623.6.808.1b50592cSXAs1a&#34;&gt;阿里云推流SDK文档&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>YYCache 源码收获</title>
      <link>https://rangerzz.github.io/post/2/</link>
      <pubDate>Wed, 29 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://rangerzz.github.io/post/2/</guid>
      
        <description>

&lt;h1 id=&#34;yycache-源码收获&#34;&gt;YYCache 源码收获&lt;/h1&gt;

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;YYCache是一个高性能的线程安全的缓存框架,分为内存缓存和磁盘缓存两部分,内存缓存通过双向链表实现高速存取,磁盘缓存通过SQLite和文件存储实现高性能存取.&lt;/p&gt;

&lt;h2 id=&#34;收获&#34;&gt;收获&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;双向链表(_YYLinkedMap, _YYLinkedMapNode)数据结构的实现和LRU(least-recently-used)缓存淘汰算法的实现.从而衍生的使我明晰了算法复杂度的两个维度,即时间复杂度和空间复杂度的内涵,更对Hash算法产生了浓厚兴趣.&lt;/li&gt;
&lt;li&gt;YYCache的接口都是线程安全的,其中YYMemoryCache通过pthread_mutex(互斥锁)在进行读取操作时加锁解锁来保证线程安全,YYDiskCache通过dispatch_semaphore(信号量)来保证线程安全.从而衍生的使我了解更多关于锁的概念与应用.&lt;/li&gt;
&lt;li&gt;更底层同时也更高效的CFMutableDictionaryRef的API及使用.&lt;/li&gt;
&lt;li&gt;SQLite的简单使用,未来结合阅读FMDB源码应该收获更多.&lt;/li&gt;
&lt;li&gt;开发者的设计思路与编程技巧.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;思考&#34;&gt;思考&lt;/h2&gt;

&lt;p&gt;工作4年,忙忙碌碌,更多的是在用轮子造应用,伴随着公司的策略,上线运营和放弃运营的应用也写了十多款,工作前两年,写各种类型的应用确实扩宽了知识的广度,但很是缺乏知识的深度,尤其近一年来感觉到深深地技术瓶颈,日常工作更多的是重复之前写过的很多代码,用相同的技术知识点来不同的排列组合.&lt;/p&gt;

&lt;p&gt;随着困惑的加深,自学提高迫在眉睫,期间购入了很多书籍,也开始阅读优秀开源项目的源码,讲真,就我近期阅读源码的收获,阅读源码真的是提高自我的有效方式,代码应该是开发者沟通最有效的方式,而阅读源码则会让你产生优秀开发者心灵交流的感觉.&lt;/p&gt;

&lt;p&gt;未来我想我会继续阅读更多的优秀源码和书籍,并记录下收获.&lt;/p&gt;

&lt;h2 id=&#34;扩展阅读&#34;&gt;扩展阅读&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://knightsj.github.io/2018/02/03/YYCache%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/&#34;&gt;YYCache 源码解析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/8b8a01dd6356&#34;&gt;iOS 开发中的八种锁（Lock）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/&#34;&gt;关于 @synchronized，这儿比你想知道的还要多&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/2dc347464188&#34;&gt;正确使用多线程同步锁@synchronized()&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/&#34;&gt;不再安全的 OSSpinLock&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>第一篇博文</title>
      <link>https://rangerzz.github.io/post/1/</link>
      <pubDate>Tue, 21 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://rangerzz.github.io/post/1/</guid>
      
        <description>&lt;p&gt;本站部署在github.io，基于Hugo建站，使用了Jane主题。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://keysaim.github.io/post/blog/2017-08-15-how-to-setup-your-github-io-blog/&#34;&gt;github.io部署参考&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://keysaim.github.io/post/blog/deploy-hugo-blog-in-github.io/&#34;&gt;Hugo建站参考&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://themes.gohugo.io/hugo-theme-jane/&#34;&gt;Jane主题参考&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>