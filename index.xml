<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ranger&#39;s blog</title>
    <link>https://rangerzz.github.io/</link>
    <description>Recent content on Ranger&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 21 Aug 2018 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://rangerzz.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://rangerzz.github.io/about/</link>
      <pubDate>Tue, 21 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://rangerzz.github.io/about/</guid>
      
        <description>&lt;p&gt;Ranger的博客站。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>ReplayKit 2录屏直播</title>
      <link>https://rangerzz.github.io/post/replaykit-2%E5%BD%95%E5%B1%8F%E7%9B%B4%E6%92%AD/</link>
      <pubDate>Tue, 23 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://rangerzz.github.io/post/replaykit-2%E5%BD%95%E5%B1%8F%E7%9B%B4%E6%92%AD/</guid>
      
        <description>

&lt;h2 id=&#34;概览&#34;&gt;概览&lt;/h2&gt;

&lt;p&gt;iOS 11新添加了用户从控制中心开启全局的录屏功能(在此之前只能实现应用内录制),这个功能和API(ReplayKit 2)的添加,使得录屏直播以及其他录屏相关的玩法拥有了无限可能.
刚好近一个月我司产品添加相关功能,并由我完成,从查阅相关文档到添加录屏直播的第一版App上线,用了2周多时间,期间尝试了阿里和腾讯的SDK,下面就回顾一下这段时间的学习和成长.&lt;/p&gt;

&lt;h2 id=&#34;介绍extension&#34;&gt;介绍Extension&lt;/h2&gt;

&lt;p&gt;Xcode 9中,添加了&amp;rsquo;Broadcast Upload Extension&amp;rsquo; 和 &amp;lsquo;Broadcast Setup UI Extension&amp;rsquo;,用来实现相关功能,需要在File -&amp;gt; New -&amp;gt; Target中创建他们.&lt;/p&gt;

&lt;h3 id=&#34;broadcast-upload-extension&#34;&gt;&amp;lsquo;Broadcast Upload Extension&amp;rsquo;&lt;/h3&gt;

&lt;p&gt;最为核心的是&amp;rsquo;Broadcast Upload Extension&amp;rsquo;(后简称&amp;rsquo;Upload&amp;rsquo;),&amp;lsquo;Upload&amp;rsquo;中有多个系统回调方法,被用来告知录屏的开始,结束,暂停,恢复和采集到的音视频信息,大多数需求要通过该Extension实现.
&amp;lsquo;Upload&amp;rsquo;独立于App存在,运行时也不依赖App,是一个独立的进程,也就是说,用户并不需要启动App,就可以使用录屏功能,拥有便捷,轻量的特点.&lt;/p&gt;

&lt;h3 id=&#34;broadcast-setup-ui-extension&#34;&gt;&amp;lsquo;Broadcast Setup UI Extension&amp;rsquo;&lt;/h3&gt;

&lt;p&gt;在创建&amp;rsquo;Broadcast Upload Extension&amp;rsquo;时,Xcode会询问你是否需要一并创建&amp;rsquo;Broadcast Setup UI Extension&amp;rsquo;(后称&amp;rsquo;Setup UI&amp;rsquo;),此处可以选择不创建.
&amp;lsquo;Setup UI&amp;rsquo;在iOS11添加ReplayKit 2之前需要使用,在ReplayKit 2后,用户可以在控制中心发起全局的录屏功能后本插件就没那么重要了,由于本文主要介绍ReplayKit 2,故不做详细介绍了(我觉得这是个遗留问题,ReplayKit 2新特性更好更方便,完全可以替代之前的方案).&lt;/p&gt;

&lt;h2 id=&#34;实践实现&#34;&gt;实践实现&lt;/h2&gt;

&lt;h3 id=&#34;类和方法&#34;&gt;类和方法&lt;/h3&gt;

&lt;p&gt;创建&amp;rsquo;Upload&amp;rsquo;Target后,Xcode中会创建SampleHandler类,是RPBroadcastSampleHandler的子类,类中会有如下方法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;- (void)broadcastStartedWithSetupInfo:(NSDictionary&amp;lt;NSString *,NSObject *&amp;gt; *)setupInfo {
    // User has requested to start the broadcast. Setup info from the UI extension can be supplied but optional.
}

- (void)broadcastPaused {
    // User has requested to pause the broadcast. Samples will stop being delivered.
}

- (void)broadcastResumed {
    // User has requested to resume the broadcast. Samples delivery will resume.
}

- (void)broadcastFinished {
    // User has requested to finish the broadcast.
}

- (void)processSampleBuffer:(CMSampleBufferRef)sampleBuffer withType:(RPSampleBufferType)sampleBufferType {
    
    switch (sampleBufferType) {
        case RPSampleBufferTypeVideo:
            // Handle video sample buffer
            break;
        case RPSampleBufferTypeAudioApp:
            // Handle audio sample buffer for app audio
            break;
        case RPSampleBufferTypeAudioMic:
            // Handle audio sample buffer for mic audio
            break;
            
        default:
            break;
    }
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;根据方法名和注释,显而易见的知道这些方法分别在录屏开始,暂停,恢复,结束和音视频数据是被调用,并且会传递一些信息.
简单说一下这几个方法:
* -(void)broadcastStartedWithSetupInfo:(NSDictionary&lt;NSString *,NSObject *&gt; *)setupInfo;
    本方法在用户在 控制中心-&amp;gt;屏幕录制-&amp;gt;开始直播 点击321倒数结束后被调用.此处就可以开始初始化推流器,开启推流等工作,至于setupInfo,是&amp;rsquo;Setup UI&amp;rsquo;传递过来的一些初始化信息,当然如果不使用&amp;rsquo;Setup UI&amp;rsquo;,还是有多种方式传递&amp;rsquo;Upload&amp;rsquo;插件本身无法获取的信息.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;-(void)broadcastFinished;
本方法在用户 点击屏幕状态栏-&amp;gt;系统弹窗-&amp;gt;停止 后被调用.此处可以认为&amp;rsquo;Upload&amp;rsquo;插件进程即将被结束,需要做一些资源和内存释放等工作,然后插件进程结束.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-(void)processSampleBuffer:(CMSampleBufferRef)sampleBuffer withType:(RPSampleBufferType)sampleBufferType;
本方法在-(void)broadcastStartedWithSetupInfo:(NSDictionary&lt;NSString *,NSObject *&gt; *)setupInfo被调用后,会不停的被调用,用来获取采集到的音视频信息,通过sampleBufferType区分.此处可以将音视频信息编码推流.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;消息传递与数据共享&#34;&gt;消息传递与数据共享&lt;/h3&gt;

&lt;p&gt;前文说的,&amp;lsquo;Upload&amp;rsquo;和App是相互独立的两个进程,&amp;lsquo;Upload&amp;rsquo;和App如何进行消息传递和数据共享呢,大致有如下几种方式:
* 剪贴版:通过写入剪贴板,然后插件读取剪贴板传递一些简单数据,但是可靠性太差,可以作为一种辅助手段.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;UIPasteboard *paste = [UIPasteboard generalPasteboard];
paste.string = @&amp;#34;a&amp;#34;;// 写入
NSString *a = paste.string;// 读取&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;本地推送:插件可以发送本地通知,可以用来提示用户一些录屏事件,也可以提示用户点击通知,激活App做一些操作.
```&lt;/li&gt;
&lt;li&gt;(void)sendLocalNotificationToHostAppWithTitle:(NSString *)title msg:(NSString *)msg userInfo:(NSDictionary *)userInfo {
    UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];
    UNMutableNotificationContent &lt;em&gt;content = [[UNMutableNotificationContent alloc] init];
    content.title = [NSString localizedUserNotificationStringForKey:title arguments:nil];
    content.body = [NSString localizedUserNotificationStringForKey:msg  arguments:nil];
    content.sound = [UNNotificationSound defaultSound];
    content.userInfo = userInfo;
    UNTimeIntervalNotificationTrigger&lt;/em&gt; trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:0.1f repeats:NO];
    UNNotificationRequest* request = [UNNotificationRequest requestWithIdentifier:@&amp;ldquo;ReplayKitPush&amp;rdquo; content:content trigger:trigger];&lt;br /&gt;
    [center addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) {
    }];
}
```&lt;/li&gt;
&lt;li&gt;通知:CFNotificationCenter可以发送跨进程的通知,用来做一些实时事件交互.
&lt;code&gt;
CFNotificationCenterPostNotification(CFNotificationCenterGetDarwinNotifyCenter(),kDarvinNotificationNamePushStart,NULL,nil,YES);
CFNotificationCenterAddObserver(CFNotificationCenterGetDarwinNotifyCenter(), (__bridge const void *)(self), onDarwinReplayKitPushStart, kDarvinNotificationNamePushStart, NULL, CFNotificationSuspensionBehaviorDeliverImmediately);
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;AppGroup:开启AppGroup后,同一AppGroup的成员,可以共享沙盒数据,也就是说,App可以读取&amp;rdquo;Upload&amp;rdquo;的录屏文件,&amp;ldquo;Upload&amp;rdquo;可以从App获取必要信息.AppGroup需要在 Capabilities -&amp;gt; AppGroup 中开启,App和插件都要打开,后会生成.entitlements文件,会有一个group.BundleIdentifier的标识.
&lt;code&gt;
NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:AppGroupId];// 共享的沙盒路径
NSUserDefaults *userDefault = [[NSUserDefaults alloc] initWithSuiteName:AppGroupId];// 共享的userDefault
&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;注意线程问题&#34;&gt;注意线程问题&lt;/h3&gt;

&lt;p&gt;&amp;ldquo;Upload&amp;rdquo;中开始各种方法被调用的线程都不是主线程,所以要注意线程同步问题,并且实测如果强行回调到主线做一些耗时操作,会使&amp;rdquo;Upload&amp;rdquo;崩溃,所以非不得已(&amp;ldquo;Upload&amp;rdquo;也没有需要处理的UI事件),尽量使用当前线程,并且在开始和结束的方法中加同步锁.
以及如果开启NSTimer的话,由于不是主线程,记得开启当前线程的Runloop!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;- (void)setupTimerThread {
    if (self.tiemrThread.executing) {
        return;
    }
    
    self.tiemrThread = [[NSThread alloc] initWithTarget:self selector:@selector(startTimer) object:nil];
    self.tiemrThread.name = @&amp;#34;timerThread&amp;#34;;
    [self.tiemrThread start];
}

- (void)startTimer {
    @autoreleasepool {

        [self postPushStatus:ANPushHeartbeatStatusPushing];
        self.timer = [NSTimer timerWithTimeInterval:15 repeats:YES block:^(NSTimer * _Nonnull timer) {
        }];
    
        [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSDefaultRunLoopMode];

        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
    }
}

- (void)stopTimer {
    [self performSelector:@selector(invalidateTimer) onThread:self.tiemrThread withObject:nil waitUntilDone:NO];
}

- (void)invalidateTimer {
    if (self.timer) {
        [self.timer invalidate];
        self.timer = nil;
    }
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;以上是一些开发过程中学习到知识与坑点,如有问题,欢迎交流探讨.&lt;/p&gt;

&lt;h2 id=&#34;参考链接&#34;&gt;参考链接&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2018/601/&#34;&gt;Live Screen Broadcast with ReplayKit&lt;/a&gt;
&lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2017/606&#34;&gt;What&amp;rsquo;s New with Screen Recording and Live Broadcast&lt;/a&gt;
&lt;a href=&#34;https://cloud.tencent.com/document/product/454/7883&#34;&gt;腾讯云ReplayKit文档&lt;/a&gt;
&lt;a href=&#34;https://help.aliyun.com/document_detail/45263.html?spm=a2c4g.11186623.6.808.1b50592cSXAs1a&#34;&gt;阿里云推流SDK文档&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>YYCache 源码收获</title>
      <link>https://rangerzz.github.io/post/yycache-%E6%BA%90%E7%A0%81%E6%94%B6%E8%8E%B7/</link>
      <pubDate>Wed, 29 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://rangerzz.github.io/post/yycache-%E6%BA%90%E7%A0%81%E6%94%B6%E8%8E%B7/</guid>
      
        <description>

&lt;h1 id=&#34;yycache-源码收获&#34;&gt;YYCache 源码收获&lt;/h1&gt;

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;YYCache是一个高性能的线程安全的缓存框架,分为内存缓存和磁盘缓存两部分,内存缓存通过双向链表实现高速存取,磁盘缓存通过SQLite和文件存储实现高性能存取.&lt;/p&gt;

&lt;h2 id=&#34;收获&#34;&gt;收获&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;双向链表(_YYLinkedMap, _YYLinkedMapNode)数据结构的实现和LRU(least-recently-used)缓存淘汰算法的实现.从而衍生的使我明晰了算法复杂度的两个维度,即时间复杂度和空间复杂度的内涵,更对Hash算法产生了浓厚兴趣.&lt;/li&gt;
&lt;li&gt;YYCache的接口都是线程安全的,其中YYMemoryCache通过pthread_mutex(互斥锁)在进行读取操作时加锁解锁来保证线程安全,YYDiskCache通过dispatch_semaphore(信号量)来保证线程安全.从而衍生的使我了解更多关于锁的概念与应用.&lt;/li&gt;
&lt;li&gt;更底层同时也更高效的CFMutableDictionaryRef的API及使用.&lt;/li&gt;
&lt;li&gt;SQLite的简单使用,未来结合阅读FMDB源码应该收获更多.&lt;/li&gt;
&lt;li&gt;开发者的设计思路与编程技巧.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;感悟&#34;&gt;感悟&lt;/h2&gt;

&lt;p&gt;工作4年,忙忙碌碌,更多的是在用轮子造应用,伴随着公司的策略,上线运营和放弃运营的应用也写了十多款,工作前两年,写各种类型的应用确实扩宽了知识的广度,但很是缺乏知识的深度,尤其近一年来感觉到深深地技术瓶颈,日常工作更多的是重复之前写过的很多代码,用相同的技术知识点来不同的排列组合.&lt;/p&gt;

&lt;p&gt;随着困惑的加深,自学提高迫在眉睫,期间购入了很多书籍,也开始阅读优秀开源项目的源码,讲真,就我近期阅读源码的收获,阅读源码真的是提高自我的有效方式,代码应该是开发者沟通最有效的方式,而阅读源码则会让你产生优秀开发者心灵交流的感觉.&lt;/p&gt;

&lt;p&gt;未来我想我会继续阅读更多的优秀源码和书籍,并记录下收获.&lt;/p&gt;

&lt;h2 id=&#34;扩展阅读&#34;&gt;扩展阅读&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://knightsj.github.io/2018/02/03/YYCache%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/&#34;&gt;YYCache 源码解析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/8b8a01dd6356&#34;&gt;iOS 开发中的八种锁（Lock）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/&#34;&gt;关于 @synchronized，这儿比你想知道的还要多&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/2dc347464188&#34;&gt;正确使用多线程同步锁@synchronized()&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/&#34;&gt;不再安全的 OSSpinLock&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>第一篇博文</title>
      <link>https://rangerzz.github.io/post/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/</link>
      <pubDate>Tue, 21 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://rangerzz.github.io/post/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/</guid>
      
        <description>&lt;p&gt;本站部署在github.io，基于Hugo建站，使用了Jane主题。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://keysaim.github.io/post/blog/2017-08-15-how-to-setup-your-github-io-blog/&#34;&gt;github.io部署参考&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://keysaim.github.io/post/blog/deploy-hugo-blog-in-github.io/&#34;&gt;Hugo建站参考&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://themes.gohugo.io/hugo-theme-jane/&#34;&gt;Jane主题参考&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>