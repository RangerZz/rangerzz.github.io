<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ranger&#39;s blog</title>
    <link>https://rangerzz.github.io/</link>
    <description>Recent content on Ranger&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 21 Aug 2018 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://rangerzz.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://rangerzz.github.io/about/</link>
      <pubDate>Tue, 21 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://rangerzz.github.io/about/</guid>
      
        <description>&lt;p&gt;Ranger的博客站。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>正则表达式</title>
      <link>https://rangerzz.github.io/post/6/</link>
      <pubDate>Fri, 15 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://rangerzz.github.io/post/6/</guid>
      
        <description>

&lt;h2 id=&#34;js中正则表达式两种创建方式&#34;&gt;JS中正则表达式两种创建方式:&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;字面量: &lt;code&gt;let reg = /abc/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;RegExp构造函数: &lt;code&gt;let reg = new RegExp(&#39;abc&#39;)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;修饰符&#34;&gt;修饰符&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;i&lt;/code&gt;:忽略大小写&lt;/p&gt;

&lt;p&gt;&lt;code&gt;g&lt;/code&gt;:全局匹配&lt;/p&gt;

&lt;p&gt;&lt;code&gt;m&lt;/code&gt;:多行匹配&lt;/p&gt;

&lt;h2 id=&#34;元字符&#34;&gt;元字符&lt;/h2&gt;

&lt;p&gt;大多数字符在正则表达式中只是是字面意思如/a/匹配a,这类字符叫做&lt;strong&gt;字面量字符&lt;/strong&gt;
除了字面量字符,还有一部分特殊字符,不代表其字面意思,叫做&lt;strong&gt;元字符&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;字符类&#34;&gt;字符类&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;.&lt;/code&gt;:点字符匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。
&lt;em&gt;注意，对于码点大于0xFFFF的 Unicode 字符，点字符不能正确匹配，会认为这是两个字符。&lt;/em&gt;
&lt;code&gt;|&lt;/code&gt;:或关系&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[a-z]&lt;/code&gt;:表示26个小写字母任意一个都可以匹配&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[0-9]&lt;/code&gt;:表示数字0-9任意一个数字可以匹配&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[a-zA-Z0-9]&lt;/code&gt;:表示大小写a-z0-9任意一个可以匹配&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[^0-9]&lt;/code&gt;:表示非0-9的任意一个字符可以匹配&lt;/p&gt;

&lt;h3 id=&#34;特殊字符&#34;&gt;特殊字符&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;\w&lt;/code&gt;:匹配字母数字下划线_ ,相当于&lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\W&lt;/code&gt;:匹配非字母数字下划线_ ,相当于&lt;code&gt;[^a-zA-Z0-9_]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\d&lt;/code&gt;:匹配数字,相当于&lt;code&gt;[0-9]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\D&lt;/code&gt;:匹配数字,相当于&lt;code&gt;[^0-9]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\s&lt;/code&gt;:匹配空格（包括换行符、制表符、空格符等,相等于[ \t\r\n\v\f]&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\S&lt;/code&gt;:匹配非空格的字符，相当于[^ \t\r\n\v\f]&lt;/p&gt;

&lt;h3 id=&#34;重复字符&#34;&gt;重复字符&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;{m,n}&lt;/code&gt;:匹配m-n个,包含m,n&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{m}&lt;/code&gt;:匹配m个,限定m个&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{m,}&lt;/code&gt;:匹配m个或m个以上&lt;/p&gt;

&lt;h3 id=&#34;量词&#34;&gt;量词&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;*&lt;/code&gt;:匹配0个,1个或多个&lt;/p&gt;

&lt;p&gt;&lt;code&gt;+&lt;/code&gt;:匹配1个或者多个&lt;/p&gt;

&lt;p&gt;&lt;code&gt;?&lt;/code&gt;:匹配0个或者1个
&lt;strong&gt;非贪婪模式:量词符后加&lt;code&gt;?&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;位置字符&#34;&gt;位置字符&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;/^[0-9]/&lt;/code&gt;:&lt;code&gt;/^&lt;/code&gt;以0-9开始的任意一个数字可以匹配&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/[a-z]$/&lt;/code&gt;:&lt;code&gt;$/&lt;/code&gt;以a-z任意小写字母结尾的可以匹配&lt;/p&gt;

&lt;h3 id=&#34;分组&#34;&gt;分组&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;()&lt;/code&gt;:分组&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(?:[a-z])&lt;/code&gt;:非捕获性分组&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(a?(b?))&lt;/code&gt;:嵌套分组,从外向内获取&lt;/p&gt;

&lt;p&gt;&lt;code&gt;m(?=n)&lt;/code&gt;:先行断言匹配,m只有在n前面才匹配&lt;/p&gt;

&lt;p&gt;&lt;code&gt;m(?!n)&lt;/code&gt;:先行否定断言匹配,m只有不在n前面才匹配&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>2018年工作总结和思考</title>
      <link>https://rangerzz.github.io/post/5/</link>
      <pubDate>Tue, 25 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://rangerzz.github.io/post/5/</guid>
      
        <description>

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;今年春节后跳出了之前的工作内容,不再是重复性的一直做类似的事情.接手了一个新项目,并且独自负责iOS端的开发,期间陆续迭代调整方向持续到了年底.
18年初,视频答题撒币的火热,市面上诞生了许多大厂小厂的产品,我司也想结合公司业务和答题的场景,推出一款产品试水,但是随着政策出台,视听许可证的强制要求,视频直播答题的想法破灭.当时微信小程序也是热门话题,最终结合先装,我司决定开发一个短视频答题小程序.由我&lt;strong&gt;跟进&lt;/strong&gt;开发iOS端.&lt;/p&gt;

&lt;p&gt;答题形式从初版的边播视频边答题,陆续改版为先播视频再答题.答题方式也发展出定时答(每天所有用户同一时刻开始答题)和即时答(用户随时可以开始答题)两种.期间陆续添加用户系统,用户出题,积分兑换和提现等其他的常规功能.&lt;/p&gt;

&lt;p&gt;直到九月份,放弃答题相关业务的开发,转而结合我司核心业务.开发基于ReplayKit的录屏直播功能,期间遇到许多问题和挑战,之前写过&lt;a href=&#34;https://rangerzz.github.io/post/3/&#34;&gt;ReplayKit简介&lt;/a&gt;&lt;!--以及[录屏直播实现](#)(即将发布)--&gt;可以参考.&lt;/p&gt;

&lt;h2 id=&#34;思考&#34;&gt;思考&lt;/h2&gt;

&lt;h3 id=&#34;从app主导到跟进小程序&#34;&gt;从App主导到跟进小程序&lt;/h3&gt;

&lt;p&gt;之前的工作经历都是To C面向用户的产品,到现在公司后,公司主要做的是To B面向客户的业务,我的日常工作也从原来的开发主要产品App转变为现在的开发&lt;strong&gt;辅助&lt;/strong&gt;To B业务的工具,在工作中调整开发节奏和状态,也慢慢适应了.但是没想到沉寂了许久的微信小程序,在2017.12.28日,微信推出小游戏并发布&lt;strong&gt;&amp;lt;跳一跳&amp;gt;&lt;/strong&gt;后再次引发热议,而且这次不仅仅是热议,还调动了许多开发者的热情,许多&lt;strong&gt;公司与个人参与进来开发功能丰富的小程序&lt;/strong&gt;,我司也结合了直播答题的风靡和&lt;strong&gt;小程序的快速开发,微信的巨大流量和爆发式传播速度的优势&lt;/strong&gt;决定开发答题小程序.由我跟进小程序的进度开发iOS端,为什么说跟进呢?因为本次开发,从需求制定,到产品设计,到业务实现,完全是小程序或者说web式的,比如产品设计,我第一次开发像网页一样布局和交互的应用,更是第一次用web端的设计图来适配iOS端.
但是小程序显而易见的好处:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;开发迭代周期短.这点特别令我惊讶(也有以小程序为主导做产品设计的因素),小程序从开发到审核上线的整体速度都快于App,这也带来一个好处,当我需要用接口的时候,后端同事和小程序端同事调试都已经调试好了😊.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;快速的用户增长.得力于小程序在微信内便捷的传播方式,仅仅是通过朋友圈分享,我们就获得了大量用户,当然我们产品本身带有激励属性,也激发了用户传播的积极性.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;答题的一些思考&#34;&gt;答题的一些思考&lt;/h3&gt;

&lt;h4 id=&#34;答题的火热与沉寂&#34;&gt;答题的火热与沉寂&lt;/h4&gt;

&lt;p&gt;2018年年初,视频在线答题,&lt;strong&gt;撒币&lt;/strong&gt;等关键词瞬间充斥在各种媒体,可谓是全民参与,当时午餐时间同事都会准时守着手机参与其中.当时不论是大厂,视频直播行业相关公司还是无关公司,都要分一杯羹,数十款视频在线答题项目纷纷上线,大有再现16年手机直播行业的架势,但最终在视听许可证的政策下瞬间沉寂,对此不做评价,仅记录一下我的思考.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;技术方案的服务商可谓拥有最敏锐的行业嗅觉,当我想了解相关技术方案的时候,看到了阿里的整套直播答题解决方案.可以想象无论直播答题平台发了多少奖金,吸引了多少用户,烧了多少资金,提供解决方案的服务商,最终都会赚的盆满钵满.当时每天都会上线数款同类应用,也有服务商很大的功劳.结合鹅厂最近提出的着重发展To B业务,深深感受到To B业务的魅力和潜力.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;直播答题撒币当时是一个很好很热的模式,由于三方服务的完善也是没有很大的技术门槛,所以大小厂都推出相关功能,记得有UC浏览器推出的PK答题等.给我印象最为深刻的是答题作弊直播,就是在答题平台开始同步答题的同时,有些应用内会推出一个直播频道,有所谓的&amp;rdquo;专家&amp;rdquo;告诉大家该题选什么(只是正确率略微高一些,并不能保证全对),蹭热度的方式五花八门.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用户激励.当时的盛况可谓是全名参与,每场答题都有数十万人参加,其实最终答题成功的奖金少则几角多则几元,但是碎片化时间,一场答题最长不过半小时,用户参与的意愿还是很高的.所以只要有钱有激励,再加上合适的推广宣传方式,可以快速的获取到海量用户.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;答题业务的迭代历程&#34;&gt;答题业务的迭代历程&lt;/h4&gt;

&lt;p&gt;由于我司属于广告行业,所以领导结合答题的激励形式,做一个短视频(广告片)答题构思,多样化广告投放形式.答题形式经历了三个过程&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;最初的形式是边播视频边出题边答题同时进行.上线一段时间后发现,由于视频库的数量,用户可以做到看到视频开头,就知道视频大概内容,并且播放视频同时显示题目,用户可以做到定位答案在视频哪一个时间点,更有甚者可以做到不看视频直接提交答案.新老用户感受到的难度偏差导致不甚公平,老用户更容易通关,而新用户体验不佳.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;之后迭代新版,做成了将所有短视频播放一遍才会开始出题,并且不再播放视频,避免视频和题目同时出现.这样做首先客观上强迫用户需要首先看完每段视频,其次由于不是视频和题目同时出现,用户对答案的预见性降低,主观上也会更加认真观看视频,留意更多视频细节.上线一段时间后新老用户通关率明显降低.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后将答题分为定时答和即时答.首先添加即时答,用户只要有门票(激励用户传播和日活,邀请签到送门票),就可以随时开启答题,答题使用上面提到的形式,通关奖励为瓜分次数.其次定时答修改为将视频提前公布出来,新老用户都随时可看,定时答开始后只显示文字题目.保证了公平性也增加了视频观看次数,通关奖励同样是瓜分次数.至于奖金,则由本场答题产生的瓜分次数和之前即时答产生的瓜分次数叠加后均分,用户获得相应瓜分次数的奖金,获得奖金金额额多样化,更有趣味性.所以做到了在没有增加总奖金的前提下,增加了用户粘性,活跃度.更有用户上传视频和出题等功能,丰富题库.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>iOS常见权限授权</title>
      <link>https://rangerzz.github.io/post/4/</link>
      <pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://rangerzz.github.io/post/4/</guid>
      
        <description>

&lt;h2 id=&#34;权限状态-authorizationstatus&#34;&gt;权限状态 AuthorizationStatus&lt;/h2&gt;

&lt;p&gt;权限状态枚举,API比较统一,都是相关框架前缀+固定描述拼接,大致如下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;AuthorizationStatusNotDetermined&lt;/code&gt;代表还未向用户进行过询问授权,一般为应用新装或第一次请求对应权限.此时可以主动向用户请求授权.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;AuthorizationStatusRestricted&lt;/code&gt;代表对应权限被拒绝,并且用户无权改变权限状态,例如文档中举例家长控制这种情况.因此当做未授权的情况处理处理.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;AuthorizationStatusDenied&lt;/code&gt;代表被用户拒绝.此时可以提醒用户该权限无法访问,需要去设置中打开.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;AuthorizationStatusAuthorized&lt;/code&gt;代表已经获取对应权限.此时可以访问相关数据和使用相关功能.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;相册权限&#34;&gt;相册权限&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 导入框架
#import &amp;lt;Photos/Photos.h&amp;gt;

// 当前授权状态 
// status就对应上面提到的枚举以及对应含义
PHAuthorizationStatus status = [PHPhotoLibrary authorizationStatus];

// 主动请求授权
if (status == PHAuthorizationStatusNotDetermined) {
        [PHPhotoLibrary requestAuthorization:^(PHAuthorizationStatus status) {
            if (status == PHAuthorizationStatusAuthorized) {
                // 已授权 可以访问相册等操作
            }
            else {
                // 未授权 提示用户
            }
        }];
    }&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;相机-麦克风权限&#34;&gt;相机 麦克风权限&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;#import &amp;lt;AVFoundation/AVFoundation.h&amp;gt;

// AVMediaTypeVideo 相机权限
// AVMediaTypeAudio 麦克风权限

// 当前授权状态
AVAuthorizationStatus status = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo];

// 主动请求授权
if (status == AVAuthorizationStatusNotDetermined) {
        [AVCaptureDevice requestAccessForMediaType:AVMediaTypeVideo completionHandler:^(BOOL granted) {
            // granted == YES 已授权
        }];
    }&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;推送&#34;&gt;推送&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;#import &amp;lt;UserNotifications/UserNotifications.h&amp;gt;

// 获取当前授权状态
[[UNUserNotificationCenter currentNotificationCenter] getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) {
        // 当前授权状态
        UNAuthorizationStatus unStatus = settings.authorizationStatus;
        
        if (unStatus == UNAuthorizationStatusAuthorized) {
            // 已授权
        }
        else {
        // 请求授权
            [[UNUserNotificationCenter currentNotificationCenter] requestAuthorizationWithOptions:UNAuthorizationOptionAlert | UNAuthorizationOptionSound |UNAuthorizationOptionBadge completionHandler:^(BOOL granted, NSError * _Nullable error) {
                // granted == YES 已授权
            }];
        }
    }];&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;日历&#34;&gt;日历&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;#import &amp;lt;EventKit/EventKit.h&amp;gt;

// 当前授权状态 
//EKEntityTypeEvent日历 EKEntityTypeReminder提醒事项
EKAuthorizationStatus status = [EKEventStore authorizationStatusForEntityType:EKEntityTypeEvent];
    
// 未询问
    if (status == EKAuthorizationStatusNotDetermined) {
    // 请求授权
        [[[EKEventStore alloc] init] requestAccessToEntityType:EKEntityTypeEvent completion:^(BOOL granted, NSError * _Nullable error) {
            // granted == YES 已授权
        }];
    }&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;联系人&#34;&gt;联系人&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;#import &amp;lt;Contacts/Contacts.h&amp;gt;

// 当前授权状态
CNAuthorizationStatus status = [CNContactStore authorizationStatusForEntityType:CNEntityTypeContacts];
// 未询问
    if (status == CNAuthorizationStatusNotDetermined) {
    // 请求授权
        [[[CNContactStore alloc] init] requestAccessForEntityType:CNEntityTypeContacts completionHandler:^(BOOL granted, NSError * _Nullable error) {
            // granted == YES 已授权
        }];
    }&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;定位&#34;&gt;定位&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;#import &amp;lt;CoreLocation/CoreLocation.h&amp;gt;

// 需要引用 CLLocationManager
@property (nonatomic, strong) CLLocationManager *locationManager;

// 获取授权状态
CLAuthorizationStatus status = [CLLocationManager authorizationStatus];
    // 未授权
    if (status == kCLAuthorizationStatusNotDetermined) {
    // 请求一直定位
        [self.locationManager requestAlwaysAuthorization];
    // 请求使用时定位
        [self.locationManager requestWhenInUseAuthorization];
    }

// CLLocationManagerDelegate
// 定位权限变化的回调方法
- (void)locationManager:(CLLocationManager *)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status {
    
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;zrautorizationmanager&#34;&gt;ZRAutorizationManager&lt;/h2&gt;

&lt;p&gt;封装了以上所有权限的状态和授权,统一API,一行代码获取状态和请求授权.并且系统API的授权请求结果回调线程一般不是主线程,使用&lt;strong&gt;ZRAutorizationManager&lt;/strong&gt;,可以在系统API线程或在&lt;strong&gt;主线程回调授权结果&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 一个枚举统一处理授权状态
typedef NS_ENUM(NSUInteger, ZRAutorizationStatus) {
    ZRAutorizationStatusNotDetermined,// 用户还未选择是否允许授权 可以代表第一次询问
    ZRAutorizationStatusDenied,// 拒绝授权 包括 Restricted &amp;amp; Denied
    ZRAutorizationStatusAuthorized,// 已授权
    
    ZRAutorizationStatusUnknow,// 未知状态
};

// 获取授权状态
+ (ZRAutorizationStatus)autorizationStatusForType:(ZRAutorizationType)type;

// 请求授权后结果的回调是系统API回调的线程,一般不是主线程
+ (void)requestAuthorization:(ZRAutorizationType)type grantedBlock:(void (^)(BOOL granted))grantedBlock;

// 请求授权后结果的回调是主线程
+ (void)requestAuthorization:(ZRAutorizationType)type grantedBlock:(void (^)(BOOL granted))grantedBlock;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/RangerZz/ZRAutorizationManager&#34;&gt;下载查看github&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>ReplayKit 2录屏直播</title>
      <link>https://rangerzz.github.io/post/3/</link>
      <pubDate>Tue, 23 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://rangerzz.github.io/post/3/</guid>
      
        <description>

&lt;h2 id=&#34;概览&#34;&gt;概览&lt;/h2&gt;

&lt;p&gt;iOS 11新添加了用户从控制中心开启全局的录屏功能(在此之前只能实现应用内录制),这个功能和API(ReplayKit 2)的添加,使得录屏直播以及其他录屏相关的玩法拥有了无限可能.
刚好近一个月我司产品添加相关功能,并由我完成,从查阅相关文档到添加录屏直播的第一版App上线,用了2周多时间,期间尝试了阿里和腾讯的SDK,下面就回顾一下这段时间的学习和成长.&lt;/p&gt;

&lt;h2 id=&#34;介绍extension&#34;&gt;介绍Extension&lt;/h2&gt;

&lt;p&gt;Xcode 9中,添加了&amp;rsquo;Broadcast Upload Extension&amp;rsquo; 和 &amp;lsquo;Broadcast Setup UI Extension&amp;rsquo;,用来实现相关功能,需要在File -&amp;gt; New -&amp;gt; Target中创建他们.&lt;/p&gt;

&lt;h3 id=&#34;broadcast-upload-extension&#34;&gt;Broadcast Upload Extension&lt;/h3&gt;

&lt;p&gt;最为核心的是&amp;rsquo;Broadcast Upload Extension&amp;rsquo;(后简称&amp;rsquo;Upload&amp;rsquo;),&amp;lsquo;Upload&amp;rsquo;中有多个系统回调方法,被用来告知录屏的开始,结束,暂停,恢复和采集到的音视频信息,大多数需求要通过该Extension实现.
&amp;lsquo;Upload&amp;rsquo;独立于App存在,运行时也不依赖App,是一个独立的进程,也就是说,用户并不需要启动App,就可以使用录屏功能,拥有便捷,轻量的特点.&lt;/p&gt;

&lt;h3 id=&#34;broadcast-setup-ui-extension&#34;&gt;Broadcast Setup UI Extension&lt;/h3&gt;

&lt;p&gt;在创建&amp;rsquo;Broadcast Upload Extension&amp;rsquo;时,Xcode会询问你是否需要一并创建&amp;rsquo;Broadcast Setup UI Extension&amp;rsquo;(后称&amp;rsquo;Setup UI&amp;rsquo;),此处可以选择不创建.
&amp;lsquo;Setup UI&amp;rsquo;在iOS11添加ReplayKit 2之前需要使用,在ReplayKit 2后,用户可以在控制中心发起全局的录屏功能后本插件就没那么重要了,由于本文主要介绍ReplayKit 2,故不做详细介绍了(我觉得这是个遗留问题,ReplayKit 2新特性更好更方便,完全可以替代之前的方案).&lt;/p&gt;

&lt;h2 id=&#34;实践实现&#34;&gt;实践实现&lt;/h2&gt;

&lt;h3 id=&#34;类和方法&#34;&gt;类和方法&lt;/h3&gt;

&lt;p&gt;创建&amp;rsquo;Upload&amp;rsquo;Target后,Xcode中会创建SampleHandler类,是RPBroadcastSampleHandler的子类,类中会有如下方法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;- (void)broadcastStartedWithSetupInfo:(NSDictionary&amp;lt;NSString *,NSObject *&amp;gt; *)setupInfo {
    // User has requested to start the broadcast. Setup info from the UI extension can be supplied but optional.
}

- (void)broadcastPaused {
    // User has requested to pause the broadcast. Samples will stop being delivered.
}

- (void)broadcastResumed {
    // User has requested to resume the broadcast. Samples delivery will resume.
}

- (void)broadcastFinished {
    // User has requested to finish the broadcast.
}

- (void)processSampleBuffer:(CMSampleBufferRef)sampleBuffer withType:(RPSampleBufferType)sampleBufferType {
    
    switch (sampleBufferType) {
        case RPSampleBufferTypeVideo:
            // Handle video sample buffer
            break;
        case RPSampleBufferTypeAudioApp:
            // Handle audio sample buffer for app audio
            break;
        case RPSampleBufferTypeAudioMic:
            // Handle audio sample buffer for mic audio
            break;
            
        default:
            break;
    }
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;根据方法名和注释,显而易见的知道这些方法分别在录屏开始,暂停,恢复,结束和音视频数据是被调用,并且会传递一些信息.
简单说一下这几个方法:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;-(void)broadcastStartedWithSetupInfo:(NSDictionary&amp;lt;NSString *,NSObject *&amp;gt; *)setupInfo;&lt;/code&gt;本方法在用户在 控制中心-&amp;gt;屏幕录制-&amp;gt;开始直播 点击321倒数结束后被调用.此处就可以开始初始化推流器,开启推流等工作,至于setupInfo,是&amp;rsquo;Setup UI&amp;rsquo;传递过来的一些初始化信息,当然如果不使用&amp;rsquo;Setup UI&amp;rsquo;,还是有多种方式传递&amp;rsquo;Upload&amp;rsquo;插件本身无法获取的信息.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-(void)broadcastFinished;&lt;/code&gt;本方法在用户 点击屏幕状态栏-&amp;gt;系统弹窗-&amp;gt;停止 后被调用.此处可以认为&amp;rsquo;Upload&amp;rsquo;插件进程即将被结束,需要做一些资源和内存释放等工作,然后插件进程结束.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-(void)processSampleBuffer:(CMSampleBufferRef)sampleBuffer withType:(RPSampleBufferType)sampleBufferType;&lt;/code&gt;本方法在&lt;code&gt;-(void)broadcastStartedWithSetupInfo:(NSDictionary&amp;lt;NSString *,NSObject *&amp;gt; *)setupInfo;&lt;/code&gt;被调用后,会不停的被调用,用来获取采集到的音视频信息,通过sampleBufferType区分.此处可以将音视频信息编码推流.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;消息传递与数据共享&#34;&gt;消息传递与数据共享&lt;/h3&gt;

&lt;p&gt;前文说的,&amp;lsquo;Upload&amp;rsquo;和App是相互独立的两个进程,&amp;lsquo;Upload&amp;rsquo;和App如何进行消息传递和数据共享呢,大致有如下几种方式:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;剪贴版:通过写入剪贴板,然后插件读取剪贴板传递一些简单数据,但是可靠性太差,可以作为一种辅助手段.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;UIPasteboard *paste = [UIPasteboard generalPasteboard];
paste.string = @&amp;#34;a&amp;#34;;// 写入
NSString *a = paste.string;// 读取&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;本地推送:插件可以发送本地通知,可以用来提示用户一些录屏事件,也可以提示用户点击通知,激活App做一些操作.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;- (void)sendLocalNotificationToHostAppWithTitle:(NSString *)title msg:(NSString *)msg userInfo:(NSDictionary *)userInfo {
    UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];
    UNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init];
    content.title = [NSString localizedUserNotificationStringForKey:title arguments:nil];
    content.body = [NSString localizedUserNotificationStringForKey:msg  arguments:nil];
    content.sound = [UNNotificationSound defaultSound];
    content.userInfo = userInfo;
    UNTimeIntervalNotificationTrigger* trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:0.1f repeats:NO];
    UNNotificationRequest* request = [UNNotificationRequest requestWithIdentifier:@&amp;#34;ReplayKitPush&amp;#34; content:content trigger:trigger];   
    [center addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) { 
    }];
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;通知:CFNotificationCenter可以发送跨进程的通知,用来做一些实时事件交互.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;CFNotificationCenterPostNotification(CFNotificationCenterGetDarwinNotifyCenter(),kDarvinNotificationNamePushStart,NULL,nil,YES);
CFNotificationCenterAddObserver(CFNotificationCenterGetDarwinNotifyCenter(), (__bridge const void *)(self), onDarwinReplayKitPushStart, kDarvinNotificationNamePushStart, NULL, CFNotificationSuspensionBehaviorDeliverImmediately);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;AppGroup:开启AppGroup后,同一AppGroup的成员,可以共享沙盒数据,也就是说,App可以读取&amp;rdquo;Upload&amp;rdquo;的录屏文件,&amp;ldquo;Upload&amp;rdquo;可以从App获取必要信息.AppGroup需要在 Capabilities -&amp;gt; AppGroup 中开启,App和插件都要打开,后会生成.entitlements文件,会有一个group.BundleIdentifier的标识.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:AppGroupId];// 共享的沙盒路径
NSUserDefaults *userDefault = [[NSUserDefaults alloc] initWithSuiteName:AppGroupId];// 共享的userDefault&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;注意线程问题&#34;&gt;注意线程问题&lt;/h3&gt;

&lt;p&gt;&amp;ldquo;Upload&amp;rdquo;中开始各种方法被调用的线程都不是主线程,所以要注意线程同步问题,并且实测如果强行回调到主线做一些耗时操作,会使&amp;rdquo;Upload&amp;rdquo;崩溃,所以非不得已(&amp;ldquo;Upload&amp;rdquo;也没有需要处理的UI事件),尽量使用当前线程,并且在开始和结束的方法中加同步锁.
以及如果开启NSTimer的话,由于不是主线程,记得开启当前线程的Runloop!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;- (void)setupTimerThread {
    if (self.tiemrThread.executing) {
        return;
    }
    
    self.tiemrThread = [[NSThread alloc] initWithTarget:self selector:@selector(startTimer) object:nil];
    self.tiemrThread.name = @&amp;#34;timerThread&amp;#34;;
    [self.tiemrThread start];
}

- (void)startTimer {
    @autoreleasepool {

        [self postPushStatus:ANPushHeartbeatStatusPushing];
        self.timer = [NSTimer timerWithTimeInterval:15 repeats:YES block:^(NSTimer * _Nonnull timer) {
        }];
    
        [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSDefaultRunLoopMode];

        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
    }
}

- (void)stopTimer {
    [self performSelector:@selector(invalidateTimer) onThread:self.tiemrThread withObject:nil waitUntilDone:NO];
}

- (void)invalidateTimer {
    if (self.timer) {
        [self.timer invalidate];
        self.timer = nil;
    }
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;以上是一些开发过程中学习到知识与坑点,如有问题,欢迎交流探讨.&lt;/p&gt;

&lt;h2 id=&#34;参考链接&#34;&gt;参考链接&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2018/601/&#34;&gt;Live Screen Broadcast with ReplayKit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/videos/play/wwdc2017/606&#34;&gt;What&amp;rsquo;s New with Screen Recording and Live Broadcast&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://cloud.tencent.com/document/product/454/7883&#34;&gt;腾讯云ReplayKit文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://help.aliyun.com/document_detail/45263.html?spm=a2c4g.11186623.6.808.1b50592cSXAs1a&#34;&gt;阿里云推流SDK文档&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>YYCache 源码收获</title>
      <link>https://rangerzz.github.io/post/2/</link>
      <pubDate>Wed, 29 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://rangerzz.github.io/post/2/</guid>
      
        <description>

&lt;h1 id=&#34;yycache-源码收获&#34;&gt;YYCache 源码收获&lt;/h1&gt;

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;YYCache是一个高性能的线程安全的缓存框架,分为内存缓存和磁盘缓存两部分,内存缓存通过双向链表实现高速存取,磁盘缓存通过SQLite和文件存储实现高性能存取.&lt;/p&gt;

&lt;h2 id=&#34;收获&#34;&gt;收获&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;双向链表(_YYLinkedMap, _YYLinkedMapNode)数据结构的实现和LRU(least-recently-used)缓存淘汰算法的实现.从而衍生的使我明晰了算法复杂度的两个维度,即时间复杂度和空间复杂度的内涵,更对Hash算法产生了浓厚兴趣.&lt;/li&gt;
&lt;li&gt;YYCache的接口都是线程安全的,其中YYMemoryCache通过pthread_mutex(互斥锁)在进行读取操作时加锁解锁来保证线程安全,YYDiskCache通过dispatch_semaphore(信号量)来保证线程安全.从而衍生的使我了解更多关于锁的概念与应用.&lt;/li&gt;
&lt;li&gt;更底层同时也更高效的CFMutableDictionaryRef的API及使用.&lt;/li&gt;
&lt;li&gt;SQLite的简单使用,未来结合阅读FMDB源码应该收获更多.&lt;/li&gt;
&lt;li&gt;开发者的设计思路与编程技巧.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;思考&#34;&gt;思考&lt;/h2&gt;

&lt;p&gt;工作4年,忙忙碌碌,更多的是在用轮子造应用,伴随着公司的策略,上线运营和放弃运营的应用也写了十多款,工作前两年,写各种类型的应用确实扩宽了知识的广度,但很是缺乏知识的深度,尤其近一年来感觉到深深地技术瓶颈,日常工作更多的是重复之前写过的很多代码,用相同的技术知识点来不同的排列组合.&lt;/p&gt;

&lt;p&gt;随着困惑的加深,自学提高迫在眉睫,期间购入了很多书籍,也开始阅读优秀开源项目的源码,讲真,就我近期阅读源码的收获,阅读源码真的是提高自我的有效方式,代码应该是开发者沟通最有效的方式,而阅读源码则会让你产生优秀开发者心灵交流的感觉.&lt;/p&gt;

&lt;p&gt;未来我想我会继续阅读更多的优秀源码和书籍,并记录下收获.&lt;/p&gt;

&lt;h2 id=&#34;扩展阅读&#34;&gt;扩展阅读&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://knightsj.github.io/2018/02/03/YYCache%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/&#34;&gt;YYCache 源码解析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/8b8a01dd6356&#34;&gt;iOS 开发中的八种锁（Lock）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/&#34;&gt;关于 @synchronized，这儿比你想知道的还要多&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/2dc347464188&#34;&gt;正确使用多线程同步锁@synchronized()&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/&#34;&gt;不再安全的 OSSpinLock&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>第一篇博文</title>
      <link>https://rangerzz.github.io/post/1/</link>
      <pubDate>Tue, 21 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://rangerzz.github.io/post/1/</guid>
      
        <description>&lt;p&gt;本站部署在github.io，基于Hugo建站，使用了Jane主题。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://keysaim.github.io/post/blog/2017-08-15-how-to-setup-your-github-io-blog/&#34;&gt;github.io部署参考&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://keysaim.github.io/post/blog/deploy-hugo-blog-in-github.io/&#34;&gt;Hugo建站参考&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://themes.gohugo.io/hugo-theme-jane/&#34;&gt;Jane主题参考&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>